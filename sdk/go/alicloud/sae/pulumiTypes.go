// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package sae

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ApplicationInternet struct {
	// SSL certificate. `httpsCertId` is required when HTTPS is selected
	HttpsCertId *string `pulumi:"httpsCertId"`
	// SLB Port.
	Port *int `pulumi:"port"`
	// Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
	Protocol *string `pulumi:"protocol"`
	// Container port.
	TargetPort *int `pulumi:"targetPort"`
}

// ApplicationInternetInput is an input type that accepts ApplicationInternetArgs and ApplicationInternetOutput values.
// You can construct a concrete instance of `ApplicationInternetInput` via:
//
//          ApplicationInternetArgs{...}
type ApplicationInternetInput interface {
	pulumi.Input

	ToApplicationInternetOutput() ApplicationInternetOutput
	ToApplicationInternetOutputWithContext(context.Context) ApplicationInternetOutput
}

type ApplicationInternetArgs struct {
	// SSL certificate. `httpsCertId` is required when HTTPS is selected
	HttpsCertId pulumi.StringPtrInput `pulumi:"httpsCertId"`
	// SLB Port.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Container port.
	TargetPort pulumi.IntPtrInput `pulumi:"targetPort"`
}

func (ApplicationInternetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInternet)(nil)).Elem()
}

func (i ApplicationInternetArgs) ToApplicationInternetOutput() ApplicationInternetOutput {
	return i.ToApplicationInternetOutputWithContext(context.Background())
}

func (i ApplicationInternetArgs) ToApplicationInternetOutputWithContext(ctx context.Context) ApplicationInternetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInternetOutput)
}

// ApplicationInternetArrayInput is an input type that accepts ApplicationInternetArray and ApplicationInternetArrayOutput values.
// You can construct a concrete instance of `ApplicationInternetArrayInput` via:
//
//          ApplicationInternetArray{ ApplicationInternetArgs{...} }
type ApplicationInternetArrayInput interface {
	pulumi.Input

	ToApplicationInternetArrayOutput() ApplicationInternetArrayOutput
	ToApplicationInternetArrayOutputWithContext(context.Context) ApplicationInternetArrayOutput
}

type ApplicationInternetArray []ApplicationInternetInput

func (ApplicationInternetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationInternet)(nil)).Elem()
}

func (i ApplicationInternetArray) ToApplicationInternetArrayOutput() ApplicationInternetArrayOutput {
	return i.ToApplicationInternetArrayOutputWithContext(context.Background())
}

func (i ApplicationInternetArray) ToApplicationInternetArrayOutputWithContext(ctx context.Context) ApplicationInternetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInternetArrayOutput)
}

type ApplicationInternetOutput struct{ *pulumi.OutputState }

func (ApplicationInternetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInternet)(nil)).Elem()
}

func (o ApplicationInternetOutput) ToApplicationInternetOutput() ApplicationInternetOutput {
	return o
}

func (o ApplicationInternetOutput) ToApplicationInternetOutputWithContext(ctx context.Context) ApplicationInternetOutput {
	return o
}

// SSL certificate. `httpsCertId` is required when HTTPS is selected
func (o ApplicationInternetOutput) HttpsCertId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationInternet) *string { return v.HttpsCertId }).(pulumi.StringPtrOutput)
}

// SLB Port.
func (o ApplicationInternetOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ApplicationInternet) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
func (o ApplicationInternetOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationInternet) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Container port.
func (o ApplicationInternetOutput) TargetPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ApplicationInternet) *int { return v.TargetPort }).(pulumi.IntPtrOutput)
}

type ApplicationInternetArrayOutput struct{ *pulumi.OutputState }

func (ApplicationInternetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationInternet)(nil)).Elem()
}

func (o ApplicationInternetArrayOutput) ToApplicationInternetArrayOutput() ApplicationInternetArrayOutput {
	return o
}

func (o ApplicationInternetArrayOutput) ToApplicationInternetArrayOutputWithContext(ctx context.Context) ApplicationInternetArrayOutput {
	return o
}

func (o ApplicationInternetArrayOutput) Index(i pulumi.IntInput) ApplicationInternetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApplicationInternet {
		return vs[0].([]ApplicationInternet)[vs[1].(int)]
	}).(ApplicationInternetOutput)
}

type ApplicationIntranet struct {
	// SSL certificate. `httpsCertId` is required when HTTPS is selected
	HttpsCertId *string `pulumi:"httpsCertId"`
	// SLB Port.
	Port *int `pulumi:"port"`
	// Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
	Protocol *string `pulumi:"protocol"`
	// Container port.
	TargetPort *int `pulumi:"targetPort"`
}

// ApplicationIntranetInput is an input type that accepts ApplicationIntranetArgs and ApplicationIntranetOutput values.
// You can construct a concrete instance of `ApplicationIntranetInput` via:
//
//          ApplicationIntranetArgs{...}
type ApplicationIntranetInput interface {
	pulumi.Input

	ToApplicationIntranetOutput() ApplicationIntranetOutput
	ToApplicationIntranetOutputWithContext(context.Context) ApplicationIntranetOutput
}

type ApplicationIntranetArgs struct {
	// SSL certificate. `httpsCertId` is required when HTTPS is selected
	HttpsCertId pulumi.StringPtrInput `pulumi:"httpsCertId"`
	// SLB Port.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	// Container port.
	TargetPort pulumi.IntPtrInput `pulumi:"targetPort"`
}

func (ApplicationIntranetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationIntranet)(nil)).Elem()
}

func (i ApplicationIntranetArgs) ToApplicationIntranetOutput() ApplicationIntranetOutput {
	return i.ToApplicationIntranetOutputWithContext(context.Background())
}

func (i ApplicationIntranetArgs) ToApplicationIntranetOutputWithContext(ctx context.Context) ApplicationIntranetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationIntranetOutput)
}

// ApplicationIntranetArrayInput is an input type that accepts ApplicationIntranetArray and ApplicationIntranetArrayOutput values.
// You can construct a concrete instance of `ApplicationIntranetArrayInput` via:
//
//          ApplicationIntranetArray{ ApplicationIntranetArgs{...} }
type ApplicationIntranetArrayInput interface {
	pulumi.Input

	ToApplicationIntranetArrayOutput() ApplicationIntranetArrayOutput
	ToApplicationIntranetArrayOutputWithContext(context.Context) ApplicationIntranetArrayOutput
}

type ApplicationIntranetArray []ApplicationIntranetInput

func (ApplicationIntranetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationIntranet)(nil)).Elem()
}

func (i ApplicationIntranetArray) ToApplicationIntranetArrayOutput() ApplicationIntranetArrayOutput {
	return i.ToApplicationIntranetArrayOutputWithContext(context.Background())
}

func (i ApplicationIntranetArray) ToApplicationIntranetArrayOutputWithContext(ctx context.Context) ApplicationIntranetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationIntranetArrayOutput)
}

type ApplicationIntranetOutput struct{ *pulumi.OutputState }

func (ApplicationIntranetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationIntranet)(nil)).Elem()
}

func (o ApplicationIntranetOutput) ToApplicationIntranetOutput() ApplicationIntranetOutput {
	return o
}

func (o ApplicationIntranetOutput) ToApplicationIntranetOutputWithContext(ctx context.Context) ApplicationIntranetOutput {
	return o
}

// SSL certificate. `httpsCertId` is required when HTTPS is selected
func (o ApplicationIntranetOutput) HttpsCertId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationIntranet) *string { return v.HttpsCertId }).(pulumi.StringPtrOutput)
}

// SLB Port.
func (o ApplicationIntranetOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ApplicationIntranet) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Network protocol. Valid values: `TCP` ,`HTTP`,`HTTPS`.
func (o ApplicationIntranetOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationIntranet) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Container port.
func (o ApplicationIntranetOutput) TargetPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ApplicationIntranet) *int { return v.TargetPort }).(pulumi.IntPtrOutput)
}

type ApplicationIntranetArrayOutput struct{ *pulumi.OutputState }

func (ApplicationIntranetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApplicationIntranet)(nil)).Elem()
}

func (o ApplicationIntranetArrayOutput) ToApplicationIntranetArrayOutput() ApplicationIntranetArrayOutput {
	return o
}

func (o ApplicationIntranetArrayOutput) ToApplicationIntranetArrayOutputWithContext(ctx context.Context) ApplicationIntranetArrayOutput {
	return o
}

func (o ApplicationIntranetArrayOutput) Index(i pulumi.IntInput) ApplicationIntranetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApplicationIntranet {
		return vs[0].([]ApplicationIntranet)[vs[1].(int)]
	}).(ApplicationIntranetOutput)
}

type IngressDefaultRule struct {
	// Target application ID.
	AppId *string `pulumi:"appId"`
	// Target application name.
	AppName *string `pulumi:"appName"`
	// Application backend port.
	ContainerPort *int `pulumi:"containerPort"`
}

// IngressDefaultRuleInput is an input type that accepts IngressDefaultRuleArgs and IngressDefaultRuleOutput values.
// You can construct a concrete instance of `IngressDefaultRuleInput` via:
//
//          IngressDefaultRuleArgs{...}
type IngressDefaultRuleInput interface {
	pulumi.Input

	ToIngressDefaultRuleOutput() IngressDefaultRuleOutput
	ToIngressDefaultRuleOutputWithContext(context.Context) IngressDefaultRuleOutput
}

type IngressDefaultRuleArgs struct {
	// Target application ID.
	AppId pulumi.StringPtrInput `pulumi:"appId"`
	// Target application name.
	AppName pulumi.StringPtrInput `pulumi:"appName"`
	// Application backend port.
	ContainerPort pulumi.IntPtrInput `pulumi:"containerPort"`
}

func (IngressDefaultRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressDefaultRule)(nil)).Elem()
}

func (i IngressDefaultRuleArgs) ToIngressDefaultRuleOutput() IngressDefaultRuleOutput {
	return i.ToIngressDefaultRuleOutputWithContext(context.Background())
}

func (i IngressDefaultRuleArgs) ToIngressDefaultRuleOutputWithContext(ctx context.Context) IngressDefaultRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressDefaultRuleOutput)
}

func (i IngressDefaultRuleArgs) ToIngressDefaultRulePtrOutput() IngressDefaultRulePtrOutput {
	return i.ToIngressDefaultRulePtrOutputWithContext(context.Background())
}

func (i IngressDefaultRuleArgs) ToIngressDefaultRulePtrOutputWithContext(ctx context.Context) IngressDefaultRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressDefaultRuleOutput).ToIngressDefaultRulePtrOutputWithContext(ctx)
}

// IngressDefaultRulePtrInput is an input type that accepts IngressDefaultRuleArgs, IngressDefaultRulePtr and IngressDefaultRulePtrOutput values.
// You can construct a concrete instance of `IngressDefaultRulePtrInput` via:
//
//          IngressDefaultRuleArgs{...}
//
//  or:
//
//          nil
type IngressDefaultRulePtrInput interface {
	pulumi.Input

	ToIngressDefaultRulePtrOutput() IngressDefaultRulePtrOutput
	ToIngressDefaultRulePtrOutputWithContext(context.Context) IngressDefaultRulePtrOutput
}

type ingressDefaultRulePtrType IngressDefaultRuleArgs

func IngressDefaultRulePtr(v *IngressDefaultRuleArgs) IngressDefaultRulePtrInput {
	return (*ingressDefaultRulePtrType)(v)
}

func (*ingressDefaultRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IngressDefaultRule)(nil)).Elem()
}

func (i *ingressDefaultRulePtrType) ToIngressDefaultRulePtrOutput() IngressDefaultRulePtrOutput {
	return i.ToIngressDefaultRulePtrOutputWithContext(context.Background())
}

func (i *ingressDefaultRulePtrType) ToIngressDefaultRulePtrOutputWithContext(ctx context.Context) IngressDefaultRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressDefaultRulePtrOutput)
}

type IngressDefaultRuleOutput struct{ *pulumi.OutputState }

func (IngressDefaultRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressDefaultRule)(nil)).Elem()
}

func (o IngressDefaultRuleOutput) ToIngressDefaultRuleOutput() IngressDefaultRuleOutput {
	return o
}

func (o IngressDefaultRuleOutput) ToIngressDefaultRuleOutputWithContext(ctx context.Context) IngressDefaultRuleOutput {
	return o
}

func (o IngressDefaultRuleOutput) ToIngressDefaultRulePtrOutput() IngressDefaultRulePtrOutput {
	return o.ToIngressDefaultRulePtrOutputWithContext(context.Background())
}

func (o IngressDefaultRuleOutput) ToIngressDefaultRulePtrOutputWithContext(ctx context.Context) IngressDefaultRulePtrOutput {
	return o.ApplyT(func(v IngressDefaultRule) *IngressDefaultRule {
		return &v
	}).(IngressDefaultRulePtrOutput)
}

// Target application ID.
func (o IngressDefaultRuleOutput) AppId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IngressDefaultRule) *string { return v.AppId }).(pulumi.StringPtrOutput)
}

// Target application name.
func (o IngressDefaultRuleOutput) AppName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IngressDefaultRule) *string { return v.AppName }).(pulumi.StringPtrOutput)
}

// Application backend port.
func (o IngressDefaultRuleOutput) ContainerPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v IngressDefaultRule) *int { return v.ContainerPort }).(pulumi.IntPtrOutput)
}

type IngressDefaultRulePtrOutput struct{ *pulumi.OutputState }

func (IngressDefaultRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IngressDefaultRule)(nil)).Elem()
}

func (o IngressDefaultRulePtrOutput) ToIngressDefaultRulePtrOutput() IngressDefaultRulePtrOutput {
	return o
}

func (o IngressDefaultRulePtrOutput) ToIngressDefaultRulePtrOutputWithContext(ctx context.Context) IngressDefaultRulePtrOutput {
	return o
}

func (o IngressDefaultRulePtrOutput) Elem() IngressDefaultRuleOutput {
	return o.ApplyT(func(v *IngressDefaultRule) IngressDefaultRule { return *v }).(IngressDefaultRuleOutput)
}

// Target application ID.
func (o IngressDefaultRulePtrOutput) AppId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IngressDefaultRule) *string {
		if v == nil {
			return nil
		}
		return v.AppId
	}).(pulumi.StringPtrOutput)
}

// Target application name.
func (o IngressDefaultRulePtrOutput) AppName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IngressDefaultRule) *string {
		if v == nil {
			return nil
		}
		return v.AppName
	}).(pulumi.StringPtrOutput)
}

// Application backend port.
func (o IngressDefaultRulePtrOutput) ContainerPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IngressDefaultRule) *int {
		if v == nil {
			return nil
		}
		return v.ContainerPort
	}).(pulumi.IntPtrOutput)
}

type IngressRule struct {
	// Target application ID.
	AppId string `pulumi:"appId"`
	// Target application name.
	AppName string `pulumi:"appName"`
	// Application backend port.
	ContainerPort int `pulumi:"containerPort"`
	// Application domain name.
	Domain string `pulumi:"domain"`
	// URL path.
	Path string `pulumi:"path"`
}

// IngressRuleInput is an input type that accepts IngressRuleArgs and IngressRuleOutput values.
// You can construct a concrete instance of `IngressRuleInput` via:
//
//          IngressRuleArgs{...}
type IngressRuleInput interface {
	pulumi.Input

	ToIngressRuleOutput() IngressRuleOutput
	ToIngressRuleOutputWithContext(context.Context) IngressRuleOutput
}

type IngressRuleArgs struct {
	// Target application ID.
	AppId pulumi.StringInput `pulumi:"appId"`
	// Target application name.
	AppName pulumi.StringInput `pulumi:"appName"`
	// Application backend port.
	ContainerPort pulumi.IntInput `pulumi:"containerPort"`
	// Application domain name.
	Domain pulumi.StringInput `pulumi:"domain"`
	// URL path.
	Path pulumi.StringInput `pulumi:"path"`
}

func (IngressRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressRule)(nil)).Elem()
}

func (i IngressRuleArgs) ToIngressRuleOutput() IngressRuleOutput {
	return i.ToIngressRuleOutputWithContext(context.Background())
}

func (i IngressRuleArgs) ToIngressRuleOutputWithContext(ctx context.Context) IngressRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressRuleOutput)
}

// IngressRuleArrayInput is an input type that accepts IngressRuleArray and IngressRuleArrayOutput values.
// You can construct a concrete instance of `IngressRuleArrayInput` via:
//
//          IngressRuleArray{ IngressRuleArgs{...} }
type IngressRuleArrayInput interface {
	pulumi.Input

	ToIngressRuleArrayOutput() IngressRuleArrayOutput
	ToIngressRuleArrayOutputWithContext(context.Context) IngressRuleArrayOutput
}

type IngressRuleArray []IngressRuleInput

func (IngressRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IngressRule)(nil)).Elem()
}

func (i IngressRuleArray) ToIngressRuleArrayOutput() IngressRuleArrayOutput {
	return i.ToIngressRuleArrayOutputWithContext(context.Background())
}

func (i IngressRuleArray) ToIngressRuleArrayOutputWithContext(ctx context.Context) IngressRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressRuleArrayOutput)
}

type IngressRuleOutput struct{ *pulumi.OutputState }

func (IngressRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressRule)(nil)).Elem()
}

func (o IngressRuleOutput) ToIngressRuleOutput() IngressRuleOutput {
	return o
}

func (o IngressRuleOutput) ToIngressRuleOutputWithContext(ctx context.Context) IngressRuleOutput {
	return o
}

// Target application ID.
func (o IngressRuleOutput) AppId() pulumi.StringOutput {
	return o.ApplyT(func(v IngressRule) string { return v.AppId }).(pulumi.StringOutput)
}

// Target application name.
func (o IngressRuleOutput) AppName() pulumi.StringOutput {
	return o.ApplyT(func(v IngressRule) string { return v.AppName }).(pulumi.StringOutput)
}

// Application backend port.
func (o IngressRuleOutput) ContainerPort() pulumi.IntOutput {
	return o.ApplyT(func(v IngressRule) int { return v.ContainerPort }).(pulumi.IntOutput)
}

// Application domain name.
func (o IngressRuleOutput) Domain() pulumi.StringOutput {
	return o.ApplyT(func(v IngressRule) string { return v.Domain }).(pulumi.StringOutput)
}

// URL path.
func (o IngressRuleOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v IngressRule) string { return v.Path }).(pulumi.StringOutput)
}

type IngressRuleArrayOutput struct{ *pulumi.OutputState }

func (IngressRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IngressRule)(nil)).Elem()
}

func (o IngressRuleArrayOutput) ToIngressRuleArrayOutput() IngressRuleArrayOutput {
	return o
}

func (o IngressRuleArrayOutput) ToIngressRuleArrayOutputWithContext(ctx context.Context) IngressRuleArrayOutput {
	return o
}

func (o IngressRuleArrayOutput) Index(i pulumi.IntInput) IngressRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IngressRule {
		return vs[0].([]IngressRule)[vs[1].(int)]
	}).(IngressRuleOutput)
}

type GetApplicationsApplication struct {
	// The ARN of the RAM role required when pulling images across accounts.
	AcrAssumeRoleArn string `pulumi:"acrAssumeRoleArn"`
	// Application description information. No more than 1024 characters.
	AppDescription string `pulumi:"appDescription"`
	// Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
	AppName string `pulumi:"appName"`
	// The first ID of the resource.
	ApplicationId string `pulumi:"applicationId"`
	// Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
	Command string `pulumi:"command"`
	// Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
	CommandArgs string `pulumi:"commandArgs"`
	// ConfigMap mount description.
	ConfigMapMountDesc string `pulumi:"configMapMountDesc"`
	// The CPU required for each instance, in millicores, cannot be 0.
	Cpu int `pulumi:"cpu"`
	// Indicates That the Application of the Creation Time.
	CreateTime string `pulumi:"createTime"`
	// Custom host mapping in the container. For example: [{"hostName":"samplehost","ip":"127.0.0.1"}].
	CustomHostAlias string `pulumi:"customHostAlias"`
	// The operating environment used by the Pandora application.
	EdasContainerVersion string `pulumi:"edasContainerVersion"`
	// The virtual switch where the elastic network card of the application instance is located. The switch must be located in the aforementioned VPC. The switch also has a binding relationship with the SAE namespace. If it is left blank, the default is the vSwitch ID bound to the namespace.
	Envs string `pulumi:"envs"`
	// The ID of the Application.
	Id string `pulumi:"id"`
	// Mirror address. Only Image type applications can configure the mirror address.
	ImageUrl string `pulumi:"imageUrl"`
	// The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
	JarStartArgs string `pulumi:"jarStartArgs"`
	// The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
	JarStartOptions string `pulumi:"jarStartOptions"`
	// The JDK version that the deployment package depends on. Image type applications are not supported.
	Jdk string `pulumi:"jdk"`
	// Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
	Liveness string `pulumi:"liveness"`
	// The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU.
	Memory int `pulumi:"memory"`
	// The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
	MinReadyInstances int `pulumi:"minReadyInstances"`
	// Mount description.
	MountDesc string `pulumi:"mountDesc"`
	// Mount point of NAS in application VPC.
	MountHost string `pulumi:"mountHost"`
	// SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
	NamespaceId string `pulumi:"namespaceId"`
	// ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
	NasId string `pulumi:"nasId"`
	// OSS AccessKey ID.
	OssAkId string `pulumi:"ossAkId"`
	// OSS  AccessKey Secret.
	OssAkSecret string `pulumi:"ossAkSecret"`
	// OSS mount description information.
	OssMountDescs string `pulumi:"ossMountDescs"`
	// Application package type. Support FatJar, War and Image.
	PackageType string `pulumi:"packageType"`
	// Deployment package address. Only FatJar or War type applications can configure the deployment package address.
	PackageUrl string `pulumi:"packageUrl"`
	// The version number of the deployment package. Required when the Package Type is War and FatJar.
	PackageVersion string `pulumi:"packageVersion"`
	// The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don't need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
	PhpArmsConfigLocation string `pulumi:"phpArmsConfigLocation"`
	// PHP configuration file content.
	PhpConfig string `pulumi:"phpConfig"`
	// PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
	PhpConfigLocation string `pulumi:"phpConfigLocation"`
	// Execute the script after startup, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
	PostStart string `pulumi:"postStart"`
	// Execute the script before stopping, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
	PreStop string `pulumi:"preStop"`
	// Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {"exec":{"command":["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds ":2}.
	Readiness string `pulumi:"readiness"`
	RegionId  string `pulumi:"regionId"`
	// Initial number of instances.
	Replicas       int    `pulumi:"replicas"`
	RepoName       string `pulumi:"repoName"`
	RepoNamespace  string `pulumi:"repoNamespace"`
	RepoOriginType string `pulumi:"repoOriginType"`
	// Security group ID.
	SecurityGroupId string `pulumi:"securityGroupId"`
	// SLS  configuration.
	SlsConfigs string `pulumi:"slsConfigs"`
	// The status of the resource.
	Status string `pulumi:"status"`
	// Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60.
	TerminationGracePeriodSeconds int `pulumi:"terminationGracePeriodSeconds"`
	// Time zone, the default value is Asia/Shanghai.
	Timezone string `pulumi:"timezone"`
	// Tomcat file configuration, set to "" or "{}" means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL.
	TomcatConfig string `pulumi:"tomcatConfig"`
	// The VPC corresponding to the SAE namespace. In SAE, a namespace can only correspond to one VPC and cannot be modified. Creating a SAE application in the namespace for the first time will form a binding relationship. Multiple namespaces can correspond to a VPC. If you leave it blank, it will default to the VPC ID bound to the namespace.
	VpcId string `pulumi:"vpcId"`
	// The vswitch id.
	VswitchId string `pulumi:"vswitchId"`
	// WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap "$@" start.
	WarStartOptions string `pulumi:"warStartOptions"`
	// The version of tomcat that the deployment package depends on. Image type applications are not supported.
	WebContainer string `pulumi:"webContainer"`
}

// GetApplicationsApplicationInput is an input type that accepts GetApplicationsApplicationArgs and GetApplicationsApplicationOutput values.
// You can construct a concrete instance of `GetApplicationsApplicationInput` via:
//
//          GetApplicationsApplicationArgs{...}
type GetApplicationsApplicationInput interface {
	pulumi.Input

	ToGetApplicationsApplicationOutput() GetApplicationsApplicationOutput
	ToGetApplicationsApplicationOutputWithContext(context.Context) GetApplicationsApplicationOutput
}

type GetApplicationsApplicationArgs struct {
	// The ARN of the RAM role required when pulling images across accounts.
	AcrAssumeRoleArn pulumi.StringInput `pulumi:"acrAssumeRoleArn"`
	// Application description information. No more than 1024 characters.
	AppDescription pulumi.StringInput `pulumi:"appDescription"`
	// Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
	AppName pulumi.StringInput `pulumi:"appName"`
	// The first ID of the resource.
	ApplicationId pulumi.StringInput `pulumi:"applicationId"`
	// Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
	Command pulumi.StringInput `pulumi:"command"`
	// Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
	CommandArgs pulumi.StringInput `pulumi:"commandArgs"`
	// ConfigMap mount description.
	ConfigMapMountDesc pulumi.StringInput `pulumi:"configMapMountDesc"`
	// The CPU required for each instance, in millicores, cannot be 0.
	Cpu pulumi.IntInput `pulumi:"cpu"`
	// Indicates That the Application of the Creation Time.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// Custom host mapping in the container. For example: [{"hostName":"samplehost","ip":"127.0.0.1"}].
	CustomHostAlias pulumi.StringInput `pulumi:"customHostAlias"`
	// The operating environment used by the Pandora application.
	EdasContainerVersion pulumi.StringInput `pulumi:"edasContainerVersion"`
	// The virtual switch where the elastic network card of the application instance is located. The switch must be located in the aforementioned VPC. The switch also has a binding relationship with the SAE namespace. If it is left blank, the default is the vSwitch ID bound to the namespace.
	Envs pulumi.StringInput `pulumi:"envs"`
	// The ID of the Application.
	Id pulumi.StringInput `pulumi:"id"`
	// Mirror address. Only Image type applications can configure the mirror address.
	ImageUrl pulumi.StringInput `pulumi:"imageUrl"`
	// The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
	JarStartArgs pulumi.StringInput `pulumi:"jarStartArgs"`
	// The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
	JarStartOptions pulumi.StringInput `pulumi:"jarStartOptions"`
	// The JDK version that the deployment package depends on. Image type applications are not supported.
	Jdk pulumi.StringInput `pulumi:"jdk"`
	// Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
	Liveness pulumi.StringInput `pulumi:"liveness"`
	// The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU.
	Memory pulumi.IntInput `pulumi:"memory"`
	// The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
	MinReadyInstances pulumi.IntInput `pulumi:"minReadyInstances"`
	// Mount description.
	MountDesc pulumi.StringInput `pulumi:"mountDesc"`
	// Mount point of NAS in application VPC.
	MountHost pulumi.StringInput `pulumi:"mountHost"`
	// SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
	NamespaceId pulumi.StringInput `pulumi:"namespaceId"`
	// ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
	NasId pulumi.StringInput `pulumi:"nasId"`
	// OSS AccessKey ID.
	OssAkId pulumi.StringInput `pulumi:"ossAkId"`
	// OSS  AccessKey Secret.
	OssAkSecret pulumi.StringInput `pulumi:"ossAkSecret"`
	// OSS mount description information.
	OssMountDescs pulumi.StringInput `pulumi:"ossMountDescs"`
	// Application package type. Support FatJar, War and Image.
	PackageType pulumi.StringInput `pulumi:"packageType"`
	// Deployment package address. Only FatJar or War type applications can configure the deployment package address.
	PackageUrl pulumi.StringInput `pulumi:"packageUrl"`
	// The version number of the deployment package. Required when the Package Type is War and FatJar.
	PackageVersion pulumi.StringInput `pulumi:"packageVersion"`
	// The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don't need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
	PhpArmsConfigLocation pulumi.StringInput `pulumi:"phpArmsConfigLocation"`
	// PHP configuration file content.
	PhpConfig pulumi.StringInput `pulumi:"phpConfig"`
	// PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
	PhpConfigLocation pulumi.StringInput `pulumi:"phpConfigLocation"`
	// Execute the script after startup, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
	PostStart pulumi.StringInput `pulumi:"postStart"`
	// Execute the script before stopping, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
	PreStop pulumi.StringInput `pulumi:"preStop"`
	// Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {"exec":{"command":["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds ":2}.
	Readiness pulumi.StringInput `pulumi:"readiness"`
	RegionId  pulumi.StringInput `pulumi:"regionId"`
	// Initial number of instances.
	Replicas       pulumi.IntInput    `pulumi:"replicas"`
	RepoName       pulumi.StringInput `pulumi:"repoName"`
	RepoNamespace  pulumi.StringInput `pulumi:"repoNamespace"`
	RepoOriginType pulumi.StringInput `pulumi:"repoOriginType"`
	// Security group ID.
	SecurityGroupId pulumi.StringInput `pulumi:"securityGroupId"`
	// SLS  configuration.
	SlsConfigs pulumi.StringInput `pulumi:"slsConfigs"`
	// The status of the resource.
	Status pulumi.StringInput `pulumi:"status"`
	// Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60.
	TerminationGracePeriodSeconds pulumi.IntInput `pulumi:"terminationGracePeriodSeconds"`
	// Time zone, the default value is Asia/Shanghai.
	Timezone pulumi.StringInput `pulumi:"timezone"`
	// Tomcat file configuration, set to "" or "{}" means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL.
	TomcatConfig pulumi.StringInput `pulumi:"tomcatConfig"`
	// The VPC corresponding to the SAE namespace. In SAE, a namespace can only correspond to one VPC and cannot be modified. Creating a SAE application in the namespace for the first time will form a binding relationship. Multiple namespaces can correspond to a VPC. If you leave it blank, it will default to the VPC ID bound to the namespace.
	VpcId pulumi.StringInput `pulumi:"vpcId"`
	// The vswitch id.
	VswitchId pulumi.StringInput `pulumi:"vswitchId"`
	// WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap "$@" start.
	WarStartOptions pulumi.StringInput `pulumi:"warStartOptions"`
	// The version of tomcat that the deployment package depends on. Image type applications are not supported.
	WebContainer pulumi.StringInput `pulumi:"webContainer"`
}

func (GetApplicationsApplicationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetApplicationsApplication)(nil)).Elem()
}

func (i GetApplicationsApplicationArgs) ToGetApplicationsApplicationOutput() GetApplicationsApplicationOutput {
	return i.ToGetApplicationsApplicationOutputWithContext(context.Background())
}

func (i GetApplicationsApplicationArgs) ToGetApplicationsApplicationOutputWithContext(ctx context.Context) GetApplicationsApplicationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetApplicationsApplicationOutput)
}

// GetApplicationsApplicationArrayInput is an input type that accepts GetApplicationsApplicationArray and GetApplicationsApplicationArrayOutput values.
// You can construct a concrete instance of `GetApplicationsApplicationArrayInput` via:
//
//          GetApplicationsApplicationArray{ GetApplicationsApplicationArgs{...} }
type GetApplicationsApplicationArrayInput interface {
	pulumi.Input

	ToGetApplicationsApplicationArrayOutput() GetApplicationsApplicationArrayOutput
	ToGetApplicationsApplicationArrayOutputWithContext(context.Context) GetApplicationsApplicationArrayOutput
}

type GetApplicationsApplicationArray []GetApplicationsApplicationInput

func (GetApplicationsApplicationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetApplicationsApplication)(nil)).Elem()
}

func (i GetApplicationsApplicationArray) ToGetApplicationsApplicationArrayOutput() GetApplicationsApplicationArrayOutput {
	return i.ToGetApplicationsApplicationArrayOutputWithContext(context.Background())
}

func (i GetApplicationsApplicationArray) ToGetApplicationsApplicationArrayOutputWithContext(ctx context.Context) GetApplicationsApplicationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetApplicationsApplicationArrayOutput)
}

type GetApplicationsApplicationOutput struct{ *pulumi.OutputState }

func (GetApplicationsApplicationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetApplicationsApplication)(nil)).Elem()
}

func (o GetApplicationsApplicationOutput) ToGetApplicationsApplicationOutput() GetApplicationsApplicationOutput {
	return o
}

func (o GetApplicationsApplicationOutput) ToGetApplicationsApplicationOutputWithContext(ctx context.Context) GetApplicationsApplicationOutput {
	return o
}

// The ARN of the RAM role required when pulling images across accounts.
func (o GetApplicationsApplicationOutput) AcrAssumeRoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.AcrAssumeRoleArn }).(pulumi.StringOutput)
}

// Application description information. No more than 1024 characters.
func (o GetApplicationsApplicationOutput) AppDescription() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.AppDescription }).(pulumi.StringOutput)
}

// Application Name. Combinations of numbers, letters, and dashes (-) are allowed. It must start with a letter and the maximum length is 36 characters.
func (o GetApplicationsApplicationOutput) AppName() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.AppName }).(pulumi.StringOutput)
}

// The first ID of the resource.
func (o GetApplicationsApplicationOutput) ApplicationId() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.ApplicationId }).(pulumi.StringOutput)
}

// Mirror start command. The command must be an executable object in the container. For example: sleep. Setting this command will cause the original startup command of the mirror to become invalid.
func (o GetApplicationsApplicationOutput) Command() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.Command }).(pulumi.StringOutput)
}

// Mirror startup command parameters. The parameters required for the above start command. For example: 1d.
func (o GetApplicationsApplicationOutput) CommandArgs() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.CommandArgs }).(pulumi.StringOutput)
}

// ConfigMap mount description.
func (o GetApplicationsApplicationOutput) ConfigMapMountDesc() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.ConfigMapMountDesc }).(pulumi.StringOutput)
}

// The CPU required for each instance, in millicores, cannot be 0.
func (o GetApplicationsApplicationOutput) Cpu() pulumi.IntOutput {
	return o.ApplyT(func(v GetApplicationsApplication) int { return v.Cpu }).(pulumi.IntOutput)
}

// Indicates That the Application of the Creation Time.
func (o GetApplicationsApplicationOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.CreateTime }).(pulumi.StringOutput)
}

// Custom host mapping in the container. For example: [{"hostName":"samplehost","ip":"127.0.0.1"}].
func (o GetApplicationsApplicationOutput) CustomHostAlias() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.CustomHostAlias }).(pulumi.StringOutput)
}

// The operating environment used by the Pandora application.
func (o GetApplicationsApplicationOutput) EdasContainerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.EdasContainerVersion }).(pulumi.StringOutput)
}

// The virtual switch where the elastic network card of the application instance is located. The switch must be located in the aforementioned VPC. The switch also has a binding relationship with the SAE namespace. If it is left blank, the default is the vSwitch ID bound to the namespace.
func (o GetApplicationsApplicationOutput) Envs() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.Envs }).(pulumi.StringOutput)
}

// The ID of the Application.
func (o GetApplicationsApplicationOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.Id }).(pulumi.StringOutput)
}

// Mirror address. Only Image type applications can configure the mirror address.
func (o GetApplicationsApplicationOutput) ImageUrl() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.ImageUrl }).(pulumi.StringOutput)
}

// The JAR package starts application parameters. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
func (o GetApplicationsApplicationOutput) JarStartArgs() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.JarStartArgs }).(pulumi.StringOutput)
}

// The JAR package starts the application option. Application default startup command: $JAVA_HOME/bin/java $JarStartOptions -jar $CATALINA_OPTS "$package_path" $JarStartArgs.
func (o GetApplicationsApplicationOutput) JarStartOptions() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.JarStartOptions }).(pulumi.StringOutput)
}

// The JDK version that the deployment package depends on. Image type applications are not supported.
func (o GetApplicationsApplicationOutput) Jdk() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.Jdk }).(pulumi.StringOutput)
}

// Container health check. Containers that fail the health check will be shut down and restored. Currently, only the method of issuing commands in the container is supported.
func (o GetApplicationsApplicationOutput) Liveness() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.Liveness }).(pulumi.StringOutput)
}

// The memory required for each instance, in MB, cannot be 0. One-to-one correspondence with CPU.
func (o GetApplicationsApplicationOutput) Memory() pulumi.IntOutput {
	return o.ApplyT(func(v GetApplicationsApplication) int { return v.Memory }).(pulumi.IntOutput)
}

// The Minimum Available Instance. On the Change Had Promised during the Available Number of Instances to Be.
func (o GetApplicationsApplicationOutput) MinReadyInstances() pulumi.IntOutput {
	return o.ApplyT(func(v GetApplicationsApplication) int { return v.MinReadyInstances }).(pulumi.IntOutput)
}

// Mount description.
func (o GetApplicationsApplicationOutput) MountDesc() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.MountDesc }).(pulumi.StringOutput)
}

// Mount point of NAS in application VPC.
func (o GetApplicationsApplicationOutput) MountHost() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.MountHost }).(pulumi.StringOutput)
}

// SAE namespace ID. Only namespaces whose names are lowercase letters and dashes (-) are supported, and must start with a letter. The namespace can be obtained by calling the DescribeNamespaceList interface.
func (o GetApplicationsApplicationOutput) NamespaceId() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.NamespaceId }).(pulumi.StringOutput)
}

// ID of the mounted NAS, Must be in the same region as the cluster. It must have an available mount point creation quota, or its mount point must be on a switch in the VPC. If it is not filled in and the mountDescs field is present, a NAS will be automatically purchased and mounted on the switch in the VPC by default.
func (o GetApplicationsApplicationOutput) NasId() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.NasId }).(pulumi.StringOutput)
}

// OSS AccessKey ID.
func (o GetApplicationsApplicationOutput) OssAkId() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.OssAkId }).(pulumi.StringOutput)
}

// OSS  AccessKey Secret.
func (o GetApplicationsApplicationOutput) OssAkSecret() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.OssAkSecret }).(pulumi.StringOutput)
}

// OSS mount description information.
func (o GetApplicationsApplicationOutput) OssMountDescs() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.OssMountDescs }).(pulumi.StringOutput)
}

// Application package type. Support FatJar, War and Image.
func (o GetApplicationsApplicationOutput) PackageType() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.PackageType }).(pulumi.StringOutput)
}

// Deployment package address. Only FatJar or War type applications can configure the deployment package address.
func (o GetApplicationsApplicationOutput) PackageUrl() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.PackageUrl }).(pulumi.StringOutput)
}

// The version number of the deployment package. Required when the Package Type is War and FatJar.
func (o GetApplicationsApplicationOutput) PackageVersion() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.PackageVersion }).(pulumi.StringOutput)
}

// The PHP application monitors the mount path, and you need to ensure that the PHP server will load the configuration file of this path. You don't need to pay attention to the configuration content, SAE will automatically render the correct configuration file.
func (o GetApplicationsApplicationOutput) PhpArmsConfigLocation() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.PhpArmsConfigLocation }).(pulumi.StringOutput)
}

// PHP configuration file content.
func (o GetApplicationsApplicationOutput) PhpConfig() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.PhpConfig }).(pulumi.StringOutput)
}

// PHP application startup configuration mount path, you need to ensure that the PHP server will start using this configuration file.
func (o GetApplicationsApplicationOutput) PhpConfigLocation() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.PhpConfigLocation }).(pulumi.StringOutput)
}

// Execute the script after startup, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
func (o GetApplicationsApplicationOutput) PostStart() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.PostStart }).(pulumi.StringOutput)
}

// Execute the script before stopping, the format is like: {"exec":{"command":["cat","/etc/group"]}}.
func (o GetApplicationsApplicationOutput) PreStop() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.PreStop }).(pulumi.StringOutput)
}

// Application startup status checks, containers that fail multiple health checks will be shut down and restarted. Containers that do not pass the health check will not receive SLB traffic. For example: {"exec":{"command":["sh","-c","cat /home/admin/start.sh"]},"initialDelaySeconds":30,"periodSeconds":30,"timeoutSeconds ":2}.
func (o GetApplicationsApplicationOutput) Readiness() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.Readiness }).(pulumi.StringOutput)
}

func (o GetApplicationsApplicationOutput) RegionId() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.RegionId }).(pulumi.StringOutput)
}

// Initial number of instances.
func (o GetApplicationsApplicationOutput) Replicas() pulumi.IntOutput {
	return o.ApplyT(func(v GetApplicationsApplication) int { return v.Replicas }).(pulumi.IntOutput)
}

func (o GetApplicationsApplicationOutput) RepoName() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.RepoName }).(pulumi.StringOutput)
}

func (o GetApplicationsApplicationOutput) RepoNamespace() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.RepoNamespace }).(pulumi.StringOutput)
}

func (o GetApplicationsApplicationOutput) RepoOriginType() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.RepoOriginType }).(pulumi.StringOutput)
}

// Security group ID.
func (o GetApplicationsApplicationOutput) SecurityGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.SecurityGroupId }).(pulumi.StringOutput)
}

// SLS  configuration.
func (o GetApplicationsApplicationOutput) SlsConfigs() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.SlsConfigs }).(pulumi.StringOutput)
}

// The status of the resource.
func (o GetApplicationsApplicationOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.Status }).(pulumi.StringOutput)
}

// Graceful offline timeout, the default is 30, the unit is seconds. The value range is 1~60.
func (o GetApplicationsApplicationOutput) TerminationGracePeriodSeconds() pulumi.IntOutput {
	return o.ApplyT(func(v GetApplicationsApplication) int { return v.TerminationGracePeriodSeconds }).(pulumi.IntOutput)
}

// Time zone, the default value is Asia/Shanghai.
func (o GetApplicationsApplicationOutput) Timezone() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.Timezone }).(pulumi.StringOutput)
}

// Tomcat file configuration, set to "" or "{}" means to delete the configuration:  useDefaultConfig: Whether to use a custom configuration, if it is true, it means that the custom configuration is not used; if it is false, it means that the custom configuration is used. If you do not use custom configuration, the following parameter configuration will not take effect.  contextInputType: Select the access path of the application.  war: No need to fill in the custom path, the access path of the application is the WAR package name. root: No need to fill in the custom path, the access path of the application is /. custom: You need to fill in the custom path in the custom path below. contextPath: custom path, this parameter only needs to be configured when the contextInputType type is custom.  httpPort: The port range is 1024~65535. Ports less than 1024 need Root permission to operate. Because the container is configured with Admin permissions, please fill in a port greater than 1024. If not configured, the default is 8080. maxThreads: Configure the number of connections in the connection pool, the default size is 400. uriEncoding: Tomcat encoding format, including UTF-8, ISO-8859-1, GBK and GB2312. If not set, the default is ISO-8859-1. useBodyEncoding: Whether to use BodyEncoding for URL.
func (o GetApplicationsApplicationOutput) TomcatConfig() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.TomcatConfig }).(pulumi.StringOutput)
}

// The VPC corresponding to the SAE namespace. In SAE, a namespace can only correspond to one VPC and cannot be modified. Creating a SAE application in the namespace for the first time will form a binding relationship. Multiple namespaces can correspond to a VPC. If you leave it blank, it will default to the VPC ID bound to the namespace.
func (o GetApplicationsApplicationOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.VpcId }).(pulumi.StringOutput)
}

// The vswitch id.
func (o GetApplicationsApplicationOutput) VswitchId() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.VswitchId }).(pulumi.StringOutput)
}

// WAR package launch application option. Application default startup command: java $JAVA_OPTS $CATALINA_OPTS [-Options] org.apache.catalina.startup.Bootstrap "$@" start.
func (o GetApplicationsApplicationOutput) WarStartOptions() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.WarStartOptions }).(pulumi.StringOutput)
}

// The version of tomcat that the deployment package depends on. Image type applications are not supported.
func (o GetApplicationsApplicationOutput) WebContainer() pulumi.StringOutput {
	return o.ApplyT(func(v GetApplicationsApplication) string { return v.WebContainer }).(pulumi.StringOutput)
}

type GetApplicationsApplicationArrayOutput struct{ *pulumi.OutputState }

func (GetApplicationsApplicationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetApplicationsApplication)(nil)).Elem()
}

func (o GetApplicationsApplicationArrayOutput) ToGetApplicationsApplicationArrayOutput() GetApplicationsApplicationArrayOutput {
	return o
}

func (o GetApplicationsApplicationArrayOutput) ToGetApplicationsApplicationArrayOutputWithContext(ctx context.Context) GetApplicationsApplicationArrayOutput {
	return o
}

func (o GetApplicationsApplicationArrayOutput) Index(i pulumi.IntInput) GetApplicationsApplicationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetApplicationsApplication {
		return vs[0].([]GetApplicationsApplication)[vs[1].(int)]
	}).(GetApplicationsApplicationOutput)
}

type GetConfigMapsMap struct {
	// The first ID of the resource.
	ConfigMapId string `pulumi:"configMapId"`
	// The Creation Time of the ConfigMap.
	CreateTime string `pulumi:"createTime"`
	// ConfigMap instance data. The value's format is a `json` string
	Data string `pulumi:"data"`
	// The Description of Config Map.
	Description string `pulumi:"description"`
	// The ID of the Config Map.
	Id string `pulumi:"id"`
	// ConfigMap instance name.
	Name string `pulumi:"name"`
	// The NamespaceId of Config Maps.
	NamespaceId string `pulumi:"namespaceId"`
}

// GetConfigMapsMapInput is an input type that accepts GetConfigMapsMap and GetConfigMapsMapOutput values.
// You can construct a concrete instance of `GetConfigMapsMapInput` via:
//
//          GetConfigMapsMap{ "key": GetConfigMapsArgs{...} }
type GetConfigMapsMapInput interface {
	pulumi.Input

	ToGetConfigMapsMapOutput() GetConfigMapsMapOutput
	ToGetConfigMapsMapOutputWithContext(context.Context) GetConfigMapsMapOutput
}

type GetConfigMapsMapArgs struct {
	// The first ID of the resource.
	ConfigMapId pulumi.StringInput `pulumi:"configMapId"`
	// The Creation Time of the ConfigMap.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// ConfigMap instance data. The value's format is a `json` string
	Data pulumi.StringInput `pulumi:"data"`
	// The Description of Config Map.
	Description pulumi.StringInput `pulumi:"description"`
	// The ID of the Config Map.
	Id pulumi.StringInput `pulumi:"id"`
	// ConfigMap instance name.
	Name pulumi.StringInput `pulumi:"name"`
	// The NamespaceId of Config Maps.
	NamespaceId pulumi.StringInput `pulumi:"namespaceId"`
}

func (GetConfigMapsMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetConfigMapsMap)(nil)).Elem()
}

func (i GetConfigMapsMapArgs) ToGetConfigMapsMapOutput() GetConfigMapsMapOutput {
	return i.ToGetConfigMapsMapOutputWithContext(context.Background())
}

func (i GetConfigMapsMapArgs) ToGetConfigMapsMapOutputWithContext(ctx context.Context) GetConfigMapsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetConfigMapsMapOutput)
}

// GetConfigMapsMapArrayInput is an input type that accepts GetConfigMapsMapArray and GetConfigMapsMapArrayOutput values.
// You can construct a concrete instance of `GetConfigMapsMapArrayInput` via:
//
//          GetConfigMapsMapArray{ GetConfigMapsMap{ "key": GetConfigMapsArgs{...} } }
type GetConfigMapsMapArrayInput interface {
	pulumi.Input

	ToGetConfigMapsMapArrayOutput() GetConfigMapsMapArrayOutput
	ToGetConfigMapsMapArrayOutputWithContext(context.Context) GetConfigMapsMapArrayOutput
}

type GetConfigMapsMapArray []GetConfigMapsMapInput

func (GetConfigMapsMapArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetConfigMapsMap)(nil)).Elem()
}

func (i GetConfigMapsMapArray) ToGetConfigMapsMapArrayOutput() GetConfigMapsMapArrayOutput {
	return i.ToGetConfigMapsMapArrayOutputWithContext(context.Background())
}

func (i GetConfigMapsMapArray) ToGetConfigMapsMapArrayOutputWithContext(ctx context.Context) GetConfigMapsMapArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetConfigMapsMapArrayOutput)
}

type GetConfigMapsMapOutput struct{ *pulumi.OutputState }

func (GetConfigMapsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetConfigMapsMap)(nil)).Elem()
}

func (o GetConfigMapsMapOutput) ToGetConfigMapsMapOutput() GetConfigMapsMapOutput {
	return o
}

func (o GetConfigMapsMapOutput) ToGetConfigMapsMapOutputWithContext(ctx context.Context) GetConfigMapsMapOutput {
	return o
}

// The first ID of the resource.
func (o GetConfigMapsMapOutput) ConfigMapId() pulumi.StringOutput {
	return o.ApplyT(func(v GetConfigMapsMap) string { return v.ConfigMapId }).(pulumi.StringOutput)
}

// The Creation Time of the ConfigMap.
func (o GetConfigMapsMapOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v GetConfigMapsMap) string { return v.CreateTime }).(pulumi.StringOutput)
}

// ConfigMap instance data. The value's format is a `json` string
func (o GetConfigMapsMapOutput) Data() pulumi.StringOutput {
	return o.ApplyT(func(v GetConfigMapsMap) string { return v.Data }).(pulumi.StringOutput)
}

// The Description of Config Map.
func (o GetConfigMapsMapOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v GetConfigMapsMap) string { return v.Description }).(pulumi.StringOutput)
}

// The ID of the Config Map.
func (o GetConfigMapsMapOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetConfigMapsMap) string { return v.Id }).(pulumi.StringOutput)
}

// ConfigMap instance name.
func (o GetConfigMapsMapOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GetConfigMapsMap) string { return v.Name }).(pulumi.StringOutput)
}

// The NamespaceId of Config Maps.
func (o GetConfigMapsMapOutput) NamespaceId() pulumi.StringOutput {
	return o.ApplyT(func(v GetConfigMapsMap) string { return v.NamespaceId }).(pulumi.StringOutput)
}

type GetConfigMapsMapArrayOutput struct{ *pulumi.OutputState }

func (GetConfigMapsMapArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetConfigMapsMap)(nil)).Elem()
}

func (o GetConfigMapsMapArrayOutput) ToGetConfigMapsMapArrayOutput() GetConfigMapsMapArrayOutput {
	return o
}

func (o GetConfigMapsMapArrayOutput) ToGetConfigMapsMapArrayOutputWithContext(ctx context.Context) GetConfigMapsMapArrayOutput {
	return o
}

func (o GetConfigMapsMapArrayOutput) Index(i pulumi.IntInput) GetConfigMapsMapOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetConfigMapsMap {
		return vs[0].([]GetConfigMapsMap)[vs[1].(int)]
	}).(GetConfigMapsMapOutput)
}

type GetIngressesIngress struct {
	// Cert Id.
	CertId string `pulumi:"certId"`
	// Default Rule.
	DefaultRule string `pulumi:"defaultRule"`
	// Description.
	Description string `pulumi:"description"`
	// The ID of the Ingress.
	Id string `pulumi:"id"`
	// The first ID of the resource.
	IngressId string `pulumi:"ingressId"`
	// SLB listening port.
	ListenerPort int `pulumi:"listenerPort"`
	// The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
	NamespaceId string `pulumi:"namespaceId"`
	// SLB ID.
	SlbId string `pulumi:"slbId"`
}

// GetIngressesIngressInput is an input type that accepts GetIngressesIngressArgs and GetIngressesIngressOutput values.
// You can construct a concrete instance of `GetIngressesIngressInput` via:
//
//          GetIngressesIngressArgs{...}
type GetIngressesIngressInput interface {
	pulumi.Input

	ToGetIngressesIngressOutput() GetIngressesIngressOutput
	ToGetIngressesIngressOutputWithContext(context.Context) GetIngressesIngressOutput
}

type GetIngressesIngressArgs struct {
	// Cert Id.
	CertId pulumi.StringInput `pulumi:"certId"`
	// Default Rule.
	DefaultRule pulumi.StringInput `pulumi:"defaultRule"`
	// Description.
	Description pulumi.StringInput `pulumi:"description"`
	// The ID of the Ingress.
	Id pulumi.StringInput `pulumi:"id"`
	// The first ID of the resource.
	IngressId pulumi.StringInput `pulumi:"ingressId"`
	// SLB listening port.
	ListenerPort pulumi.IntInput `pulumi:"listenerPort"`
	// The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
	NamespaceId pulumi.StringInput `pulumi:"namespaceId"`
	// SLB ID.
	SlbId pulumi.StringInput `pulumi:"slbId"`
}

func (GetIngressesIngressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetIngressesIngress)(nil)).Elem()
}

func (i GetIngressesIngressArgs) ToGetIngressesIngressOutput() GetIngressesIngressOutput {
	return i.ToGetIngressesIngressOutputWithContext(context.Background())
}

func (i GetIngressesIngressArgs) ToGetIngressesIngressOutputWithContext(ctx context.Context) GetIngressesIngressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetIngressesIngressOutput)
}

// GetIngressesIngressArrayInput is an input type that accepts GetIngressesIngressArray and GetIngressesIngressArrayOutput values.
// You can construct a concrete instance of `GetIngressesIngressArrayInput` via:
//
//          GetIngressesIngressArray{ GetIngressesIngressArgs{...} }
type GetIngressesIngressArrayInput interface {
	pulumi.Input

	ToGetIngressesIngressArrayOutput() GetIngressesIngressArrayOutput
	ToGetIngressesIngressArrayOutputWithContext(context.Context) GetIngressesIngressArrayOutput
}

type GetIngressesIngressArray []GetIngressesIngressInput

func (GetIngressesIngressArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetIngressesIngress)(nil)).Elem()
}

func (i GetIngressesIngressArray) ToGetIngressesIngressArrayOutput() GetIngressesIngressArrayOutput {
	return i.ToGetIngressesIngressArrayOutputWithContext(context.Background())
}

func (i GetIngressesIngressArray) ToGetIngressesIngressArrayOutputWithContext(ctx context.Context) GetIngressesIngressArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetIngressesIngressArrayOutput)
}

type GetIngressesIngressOutput struct{ *pulumi.OutputState }

func (GetIngressesIngressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetIngressesIngress)(nil)).Elem()
}

func (o GetIngressesIngressOutput) ToGetIngressesIngressOutput() GetIngressesIngressOutput {
	return o
}

func (o GetIngressesIngressOutput) ToGetIngressesIngressOutputWithContext(ctx context.Context) GetIngressesIngressOutput {
	return o
}

// Cert Id.
func (o GetIngressesIngressOutput) CertId() pulumi.StringOutput {
	return o.ApplyT(func(v GetIngressesIngress) string { return v.CertId }).(pulumi.StringOutput)
}

// Default Rule.
func (o GetIngressesIngressOutput) DefaultRule() pulumi.StringOutput {
	return o.ApplyT(func(v GetIngressesIngress) string { return v.DefaultRule }).(pulumi.StringOutput)
}

// Description.
func (o GetIngressesIngressOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v GetIngressesIngress) string { return v.Description }).(pulumi.StringOutput)
}

// The ID of the Ingress.
func (o GetIngressesIngressOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetIngressesIngress) string { return v.Id }).(pulumi.StringOutput)
}

// The first ID of the resource.
func (o GetIngressesIngressOutput) IngressId() pulumi.StringOutput {
	return o.ApplyT(func(v GetIngressesIngress) string { return v.IngressId }).(pulumi.StringOutput)
}

// SLB listening port.
func (o GetIngressesIngressOutput) ListenerPort() pulumi.IntOutput {
	return o.ApplyT(func(v GetIngressesIngress) int { return v.ListenerPort }).(pulumi.IntOutput)
}

// The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
func (o GetIngressesIngressOutput) NamespaceId() pulumi.StringOutput {
	return o.ApplyT(func(v GetIngressesIngress) string { return v.NamespaceId }).(pulumi.StringOutput)
}

// SLB ID.
func (o GetIngressesIngressOutput) SlbId() pulumi.StringOutput {
	return o.ApplyT(func(v GetIngressesIngress) string { return v.SlbId }).(pulumi.StringOutput)
}

type GetIngressesIngressArrayOutput struct{ *pulumi.OutputState }

func (GetIngressesIngressArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetIngressesIngress)(nil)).Elem()
}

func (o GetIngressesIngressArrayOutput) ToGetIngressesIngressArrayOutput() GetIngressesIngressArrayOutput {
	return o
}

func (o GetIngressesIngressArrayOutput) ToGetIngressesIngressArrayOutputWithContext(ctx context.Context) GetIngressesIngressArrayOutput {
	return o
}

func (o GetIngressesIngressArrayOutput) Index(i pulumi.IntInput) GetIngressesIngressOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetIngressesIngress {
		return vs[0].([]GetIngressesIngress)[vs[1].(int)]
	}).(GetIngressesIngressOutput)
}

type GetInstanceSpecificationsSpecification struct {
	// CPU Size, Specifications for Micronucleus.
	Cpu int `pulumi:"cpu"`
	// Whether the instance is available. The value description is as follows:
	Enable bool `pulumi:"enable"`
	// The ID of the Instance Specification.
	Id string `pulumi:"id"`
	// The first ID of the resource.
	InstanceSpecificationId string `pulumi:"instanceSpecificationId"`
	// The Memory specifications for the MB.
	Memory int `pulumi:"memory"`
	// The specification configuration name.
	SpecInfo string `pulumi:"specInfo"`
	// The specification configuration version.
	Version int `pulumi:"version"`
}

// GetInstanceSpecificationsSpecificationInput is an input type that accepts GetInstanceSpecificationsSpecificationArgs and GetInstanceSpecificationsSpecificationOutput values.
// You can construct a concrete instance of `GetInstanceSpecificationsSpecificationInput` via:
//
//          GetInstanceSpecificationsSpecificationArgs{...}
type GetInstanceSpecificationsSpecificationInput interface {
	pulumi.Input

	ToGetInstanceSpecificationsSpecificationOutput() GetInstanceSpecificationsSpecificationOutput
	ToGetInstanceSpecificationsSpecificationOutputWithContext(context.Context) GetInstanceSpecificationsSpecificationOutput
}

type GetInstanceSpecificationsSpecificationArgs struct {
	// CPU Size, Specifications for Micronucleus.
	Cpu pulumi.IntInput `pulumi:"cpu"`
	// Whether the instance is available. The value description is as follows:
	Enable pulumi.BoolInput `pulumi:"enable"`
	// The ID of the Instance Specification.
	Id pulumi.StringInput `pulumi:"id"`
	// The first ID of the resource.
	InstanceSpecificationId pulumi.StringInput `pulumi:"instanceSpecificationId"`
	// The Memory specifications for the MB.
	Memory pulumi.IntInput `pulumi:"memory"`
	// The specification configuration name.
	SpecInfo pulumi.StringInput `pulumi:"specInfo"`
	// The specification configuration version.
	Version pulumi.IntInput `pulumi:"version"`
}

func (GetInstanceSpecificationsSpecificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetInstanceSpecificationsSpecification)(nil)).Elem()
}

func (i GetInstanceSpecificationsSpecificationArgs) ToGetInstanceSpecificationsSpecificationOutput() GetInstanceSpecificationsSpecificationOutput {
	return i.ToGetInstanceSpecificationsSpecificationOutputWithContext(context.Background())
}

func (i GetInstanceSpecificationsSpecificationArgs) ToGetInstanceSpecificationsSpecificationOutputWithContext(ctx context.Context) GetInstanceSpecificationsSpecificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetInstanceSpecificationsSpecificationOutput)
}

// GetInstanceSpecificationsSpecificationArrayInput is an input type that accepts GetInstanceSpecificationsSpecificationArray and GetInstanceSpecificationsSpecificationArrayOutput values.
// You can construct a concrete instance of `GetInstanceSpecificationsSpecificationArrayInput` via:
//
//          GetInstanceSpecificationsSpecificationArray{ GetInstanceSpecificationsSpecificationArgs{...} }
type GetInstanceSpecificationsSpecificationArrayInput interface {
	pulumi.Input

	ToGetInstanceSpecificationsSpecificationArrayOutput() GetInstanceSpecificationsSpecificationArrayOutput
	ToGetInstanceSpecificationsSpecificationArrayOutputWithContext(context.Context) GetInstanceSpecificationsSpecificationArrayOutput
}

type GetInstanceSpecificationsSpecificationArray []GetInstanceSpecificationsSpecificationInput

func (GetInstanceSpecificationsSpecificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetInstanceSpecificationsSpecification)(nil)).Elem()
}

func (i GetInstanceSpecificationsSpecificationArray) ToGetInstanceSpecificationsSpecificationArrayOutput() GetInstanceSpecificationsSpecificationArrayOutput {
	return i.ToGetInstanceSpecificationsSpecificationArrayOutputWithContext(context.Background())
}

func (i GetInstanceSpecificationsSpecificationArray) ToGetInstanceSpecificationsSpecificationArrayOutputWithContext(ctx context.Context) GetInstanceSpecificationsSpecificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetInstanceSpecificationsSpecificationArrayOutput)
}

type GetInstanceSpecificationsSpecificationOutput struct{ *pulumi.OutputState }

func (GetInstanceSpecificationsSpecificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetInstanceSpecificationsSpecification)(nil)).Elem()
}

func (o GetInstanceSpecificationsSpecificationOutput) ToGetInstanceSpecificationsSpecificationOutput() GetInstanceSpecificationsSpecificationOutput {
	return o
}

func (o GetInstanceSpecificationsSpecificationOutput) ToGetInstanceSpecificationsSpecificationOutputWithContext(ctx context.Context) GetInstanceSpecificationsSpecificationOutput {
	return o
}

// CPU Size, Specifications for Micronucleus.
func (o GetInstanceSpecificationsSpecificationOutput) Cpu() pulumi.IntOutput {
	return o.ApplyT(func(v GetInstanceSpecificationsSpecification) int { return v.Cpu }).(pulumi.IntOutput)
}

// Whether the instance is available. The value description is as follows:
func (o GetInstanceSpecificationsSpecificationOutput) Enable() pulumi.BoolOutput {
	return o.ApplyT(func(v GetInstanceSpecificationsSpecification) bool { return v.Enable }).(pulumi.BoolOutput)
}

// The ID of the Instance Specification.
func (o GetInstanceSpecificationsSpecificationOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetInstanceSpecificationsSpecification) string { return v.Id }).(pulumi.StringOutput)
}

// The first ID of the resource.
func (o GetInstanceSpecificationsSpecificationOutput) InstanceSpecificationId() pulumi.StringOutput {
	return o.ApplyT(func(v GetInstanceSpecificationsSpecification) string { return v.InstanceSpecificationId }).(pulumi.StringOutput)
}

// The Memory specifications for the MB.
func (o GetInstanceSpecificationsSpecificationOutput) Memory() pulumi.IntOutput {
	return o.ApplyT(func(v GetInstanceSpecificationsSpecification) int { return v.Memory }).(pulumi.IntOutput)
}

// The specification configuration name.
func (o GetInstanceSpecificationsSpecificationOutput) SpecInfo() pulumi.StringOutput {
	return o.ApplyT(func(v GetInstanceSpecificationsSpecification) string { return v.SpecInfo }).(pulumi.StringOutput)
}

// The specification configuration version.
func (o GetInstanceSpecificationsSpecificationOutput) Version() pulumi.IntOutput {
	return o.ApplyT(func(v GetInstanceSpecificationsSpecification) int { return v.Version }).(pulumi.IntOutput)
}

type GetInstanceSpecificationsSpecificationArrayOutput struct{ *pulumi.OutputState }

func (GetInstanceSpecificationsSpecificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetInstanceSpecificationsSpecification)(nil)).Elem()
}

func (o GetInstanceSpecificationsSpecificationArrayOutput) ToGetInstanceSpecificationsSpecificationArrayOutput() GetInstanceSpecificationsSpecificationArrayOutput {
	return o
}

func (o GetInstanceSpecificationsSpecificationArrayOutput) ToGetInstanceSpecificationsSpecificationArrayOutputWithContext(ctx context.Context) GetInstanceSpecificationsSpecificationArrayOutput {
	return o
}

func (o GetInstanceSpecificationsSpecificationArrayOutput) Index(i pulumi.IntInput) GetInstanceSpecificationsSpecificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetInstanceSpecificationsSpecification {
		return vs[0].([]GetInstanceSpecificationsSpecification)[vs[1].(int)]
	}).(GetInstanceSpecificationsSpecificationOutput)
}

type GetNamespacesNamespace struct {
	// The ID of the Namespace.
	Id string `pulumi:"id"`
	// The Description of Namespace.
	NamespaceDescription string `pulumi:"namespaceDescription"`
	// The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
	NamespaceId string `pulumi:"namespaceId"`
	// The Name of Namespace.
	NamespaceName string `pulumi:"namespaceName"`
}

// GetNamespacesNamespaceInput is an input type that accepts GetNamespacesNamespaceArgs and GetNamespacesNamespaceOutput values.
// You can construct a concrete instance of `GetNamespacesNamespaceInput` via:
//
//          GetNamespacesNamespaceArgs{...}
type GetNamespacesNamespaceInput interface {
	pulumi.Input

	ToGetNamespacesNamespaceOutput() GetNamespacesNamespaceOutput
	ToGetNamespacesNamespaceOutputWithContext(context.Context) GetNamespacesNamespaceOutput
}

type GetNamespacesNamespaceArgs struct {
	// The ID of the Namespace.
	Id pulumi.StringInput `pulumi:"id"`
	// The Description of Namespace.
	NamespaceDescription pulumi.StringInput `pulumi:"namespaceDescription"`
	// The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
	NamespaceId pulumi.StringInput `pulumi:"namespaceId"`
	// The Name of Namespace.
	NamespaceName pulumi.StringInput `pulumi:"namespaceName"`
}

func (GetNamespacesNamespaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetNamespacesNamespace)(nil)).Elem()
}

func (i GetNamespacesNamespaceArgs) ToGetNamespacesNamespaceOutput() GetNamespacesNamespaceOutput {
	return i.ToGetNamespacesNamespaceOutputWithContext(context.Background())
}

func (i GetNamespacesNamespaceArgs) ToGetNamespacesNamespaceOutputWithContext(ctx context.Context) GetNamespacesNamespaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetNamespacesNamespaceOutput)
}

// GetNamespacesNamespaceArrayInput is an input type that accepts GetNamespacesNamespaceArray and GetNamespacesNamespaceArrayOutput values.
// You can construct a concrete instance of `GetNamespacesNamespaceArrayInput` via:
//
//          GetNamespacesNamespaceArray{ GetNamespacesNamespaceArgs{...} }
type GetNamespacesNamespaceArrayInput interface {
	pulumi.Input

	ToGetNamespacesNamespaceArrayOutput() GetNamespacesNamespaceArrayOutput
	ToGetNamespacesNamespaceArrayOutputWithContext(context.Context) GetNamespacesNamespaceArrayOutput
}

type GetNamespacesNamespaceArray []GetNamespacesNamespaceInput

func (GetNamespacesNamespaceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetNamespacesNamespace)(nil)).Elem()
}

func (i GetNamespacesNamespaceArray) ToGetNamespacesNamespaceArrayOutput() GetNamespacesNamespaceArrayOutput {
	return i.ToGetNamespacesNamespaceArrayOutputWithContext(context.Background())
}

func (i GetNamespacesNamespaceArray) ToGetNamespacesNamespaceArrayOutputWithContext(ctx context.Context) GetNamespacesNamespaceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetNamespacesNamespaceArrayOutput)
}

type GetNamespacesNamespaceOutput struct{ *pulumi.OutputState }

func (GetNamespacesNamespaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetNamespacesNamespace)(nil)).Elem()
}

func (o GetNamespacesNamespaceOutput) ToGetNamespacesNamespaceOutput() GetNamespacesNamespaceOutput {
	return o
}

func (o GetNamespacesNamespaceOutput) ToGetNamespacesNamespaceOutputWithContext(ctx context.Context) GetNamespacesNamespaceOutput {
	return o
}

// The ID of the Namespace.
func (o GetNamespacesNamespaceOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetNamespacesNamespace) string { return v.Id }).(pulumi.StringOutput)
}

// The Description of Namespace.
func (o GetNamespacesNamespaceOutput) NamespaceDescription() pulumi.StringOutput {
	return o.ApplyT(func(v GetNamespacesNamespace) string { return v.NamespaceDescription }).(pulumi.StringOutput)
}

// The Id of Namespace.It can contain 2 to 32 characters.The value is in format {RegionId}:{namespace}.
func (o GetNamespacesNamespaceOutput) NamespaceId() pulumi.StringOutput {
	return o.ApplyT(func(v GetNamespacesNamespace) string { return v.NamespaceId }).(pulumi.StringOutput)
}

// The Name of Namespace.
func (o GetNamespacesNamespaceOutput) NamespaceName() pulumi.StringOutput {
	return o.ApplyT(func(v GetNamespacesNamespace) string { return v.NamespaceName }).(pulumi.StringOutput)
}

type GetNamespacesNamespaceArrayOutput struct{ *pulumi.OutputState }

func (GetNamespacesNamespaceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetNamespacesNamespace)(nil)).Elem()
}

func (o GetNamespacesNamespaceArrayOutput) ToGetNamespacesNamespaceArrayOutput() GetNamespacesNamespaceArrayOutput {
	return o
}

func (o GetNamespacesNamespaceArrayOutput) ToGetNamespacesNamespaceArrayOutputWithContext(ctx context.Context) GetNamespacesNamespaceArrayOutput {
	return o
}

func (o GetNamespacesNamespaceArrayOutput) Index(i pulumi.IntInput) GetNamespacesNamespaceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetNamespacesNamespace {
		return vs[0].([]GetNamespacesNamespace)[vs[1].(int)]
	}).(GetNamespacesNamespaceOutput)
}

func init() {
	pulumi.RegisterOutputType(ApplicationInternetOutput{})
	pulumi.RegisterOutputType(ApplicationInternetArrayOutput{})
	pulumi.RegisterOutputType(ApplicationIntranetOutput{})
	pulumi.RegisterOutputType(ApplicationIntranetArrayOutput{})
	pulumi.RegisterOutputType(IngressDefaultRuleOutput{})
	pulumi.RegisterOutputType(IngressDefaultRulePtrOutput{})
	pulumi.RegisterOutputType(IngressRuleOutput{})
	pulumi.RegisterOutputType(IngressRuleArrayOutput{})
	pulumi.RegisterOutputType(GetApplicationsApplicationOutput{})
	pulumi.RegisterOutputType(GetApplicationsApplicationArrayOutput{})
	pulumi.RegisterOutputType(GetConfigMapsMapOutput{})
	pulumi.RegisterOutputType(GetConfigMapsMapArrayOutput{})
	pulumi.RegisterOutputType(GetIngressesIngressOutput{})
	pulumi.RegisterOutputType(GetIngressesIngressArrayOutput{})
	pulumi.RegisterOutputType(GetInstanceSpecificationsSpecificationOutput{})
	pulumi.RegisterOutputType(GetInstanceSpecificationsSpecificationArrayOutput{})
	pulumi.RegisterOutputType(GetNamespacesNamespaceOutput{})
	pulumi.RegisterOutputType(GetNamespacesNamespaceArrayOutput{})
}
