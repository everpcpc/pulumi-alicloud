// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package slb

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Provides an Application Load Balancer Listener resource.
// 
// For information about slb and how to use it, see [What is Server Load Balancer](https://www.alibabacloud.com/help/doc-detail/27539.htm).
// 
// For information about listener and how to use it, see [Configure a Listener](https://www.alibabacloud.com/help/doc-detail/27594.htm).
// 
type Listener struct {
	s *pulumi.ResourceState
}

// NewListener registers a new resource with the given unique name, arguments, and options.
func NewListener(ctx *pulumi.Context,
	name string, args *ListenerArgs, opts ...pulumi.ResourceOpt) (*Listener, error) {
	if args == nil || args.BackendPort == nil {
		return nil, errors.New("missing required argument 'BackendPort'")
	}
	if args == nil || args.Bandwidth == nil {
		return nil, errors.New("missing required argument 'Bandwidth'")
	}
	if args == nil || args.FrontendPort == nil {
		return nil, errors.New("missing required argument 'FrontendPort'")
	}
	if args == nil || args.LoadBalancerId == nil {
		return nil, errors.New("missing required argument 'LoadBalancerId'")
	}
	if args == nil || args.Protocol == nil {
		return nil, errors.New("missing required argument 'Protocol'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["aclId"] = nil
		inputs["aclStatus"] = nil
		inputs["aclType"] = nil
		inputs["backendPort"] = nil
		inputs["bandwidth"] = nil
		inputs["cookie"] = nil
		inputs["cookieTimeout"] = nil
		inputs["frontendPort"] = nil
		inputs["gzip"] = nil
		inputs["healthCheck"] = nil
		inputs["healthCheckConnectPort"] = nil
		inputs["healthCheckDomain"] = nil
		inputs["healthCheckHttpCode"] = nil
		inputs["healthCheckInterval"] = nil
		inputs["healthCheckTimeout"] = nil
		inputs["healthCheckType"] = nil
		inputs["healthCheckUri"] = nil
		inputs["healthyThreshold"] = nil
		inputs["instancePort"] = nil
		inputs["lbPort"] = nil
		inputs["lbProtocol"] = nil
		inputs["loadBalancerId"] = nil
		inputs["persistenceTimeout"] = nil
		inputs["protocol"] = nil
		inputs["scheduler"] = nil
		inputs["serverGroupId"] = nil
		inputs["sslCertificateId"] = nil
		inputs["stickySession"] = nil
		inputs["stickySessionType"] = nil
		inputs["unhealthyThreshold"] = nil
		inputs["xForwardedFor"] = nil
	} else {
		inputs["aclId"] = args.AclId
		inputs["aclStatus"] = args.AclStatus
		inputs["aclType"] = args.AclType
		inputs["backendPort"] = args.BackendPort
		inputs["bandwidth"] = args.Bandwidth
		inputs["cookie"] = args.Cookie
		inputs["cookieTimeout"] = args.CookieTimeout
		inputs["frontendPort"] = args.FrontendPort
		inputs["gzip"] = args.Gzip
		inputs["healthCheck"] = args.HealthCheck
		inputs["healthCheckConnectPort"] = args.HealthCheckConnectPort
		inputs["healthCheckDomain"] = args.HealthCheckDomain
		inputs["healthCheckHttpCode"] = args.HealthCheckHttpCode
		inputs["healthCheckInterval"] = args.HealthCheckInterval
		inputs["healthCheckTimeout"] = args.HealthCheckTimeout
		inputs["healthCheckType"] = args.HealthCheckType
		inputs["healthCheckUri"] = args.HealthCheckUri
		inputs["healthyThreshold"] = args.HealthyThreshold
		inputs["instancePort"] = args.InstancePort
		inputs["lbPort"] = args.LbPort
		inputs["lbProtocol"] = args.LbProtocol
		inputs["loadBalancerId"] = args.LoadBalancerId
		inputs["persistenceTimeout"] = args.PersistenceTimeout
		inputs["protocol"] = args.Protocol
		inputs["scheduler"] = args.Scheduler
		inputs["serverGroupId"] = args.ServerGroupId
		inputs["sslCertificateId"] = args.SslCertificateId
		inputs["stickySession"] = args.StickySession
		inputs["stickySessionType"] = args.StickySessionType
		inputs["unhealthyThreshold"] = args.UnhealthyThreshold
		inputs["xForwardedFor"] = args.XForwardedFor
	}
	s, err := ctx.RegisterResource("alicloud:slb/listener:Listener", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &Listener{s: s}, nil
}

// GetListener gets an existing Listener resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetListener(ctx *pulumi.Context,
	name string, id pulumi.ID, state *ListenerState, opts ...pulumi.ResourceOpt) (*Listener, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["aclId"] = state.AclId
		inputs["aclStatus"] = state.AclStatus
		inputs["aclType"] = state.AclType
		inputs["backendPort"] = state.BackendPort
		inputs["bandwidth"] = state.Bandwidth
		inputs["cookie"] = state.Cookie
		inputs["cookieTimeout"] = state.CookieTimeout
		inputs["frontendPort"] = state.FrontendPort
		inputs["gzip"] = state.Gzip
		inputs["healthCheck"] = state.HealthCheck
		inputs["healthCheckConnectPort"] = state.HealthCheckConnectPort
		inputs["healthCheckDomain"] = state.HealthCheckDomain
		inputs["healthCheckHttpCode"] = state.HealthCheckHttpCode
		inputs["healthCheckInterval"] = state.HealthCheckInterval
		inputs["healthCheckTimeout"] = state.HealthCheckTimeout
		inputs["healthCheckType"] = state.HealthCheckType
		inputs["healthCheckUri"] = state.HealthCheckUri
		inputs["healthyThreshold"] = state.HealthyThreshold
		inputs["instancePort"] = state.InstancePort
		inputs["lbPort"] = state.LbPort
		inputs["lbProtocol"] = state.LbProtocol
		inputs["loadBalancerId"] = state.LoadBalancerId
		inputs["persistenceTimeout"] = state.PersistenceTimeout
		inputs["protocol"] = state.Protocol
		inputs["scheduler"] = state.Scheduler
		inputs["serverGroupId"] = state.ServerGroupId
		inputs["sslCertificateId"] = state.SslCertificateId
		inputs["stickySession"] = state.StickySession
		inputs["stickySessionType"] = state.StickySessionType
		inputs["unhealthyThreshold"] = state.UnhealthyThreshold
		inputs["xForwardedFor"] = state.XForwardedFor
	}
	s, err := ctx.ReadResource("alicloud:slb/listener:Listener", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &Listener{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *Listener) URN() *pulumi.URNOutput {
	return r.s.URN
}

// ID is this resource's unique identifier assigned by its provider.
func (r *Listener) ID() *pulumi.IDOutput {
	return r.s.ID
}

// the id of access control list to be apply on the listener, is the id of resource alicloud_slb_acl. If `acl_status` is "on", it is mandatory. Otherwise, it will be ignored.
func (r *Listener) AclId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["aclId"])
}

// Whether to enable "acl(access control list)", the acl is specified by `acl_id`. Valid values are `on` and `off`. Default to `off`.
func (r *Listener) AclStatus() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["aclStatus"])
}

// Mode for handling the acl specified by acl_id. If `acl_status` is "on", it is mandatory. Otherwise, it will be ignored. Valid values are `white` and `black`. `white` means the Listener can only be accessed by client ip belongs to the acl; `black` means the Listener can not be accessed by client ip belongs to the acl;
func (r *Listener) AclType() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["aclType"])
}

// Port used by the Server Load Balancer instance backend. Valid value range: [1-65535].
func (r *Listener) BackendPort() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["backendPort"])
}

// Bandwidth peak of Listener. For the public network instance charged per traffic consumed, the Bandwidth on Listener can be set to -1, indicating the bandwidth peak is unlimited. Valid values are [-1, 1-1000] in Mbps.
func (r *Listener) Bandwidth() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["bandwidth"])
}

// The cookie configured on the server. It is mandatory when `sticky_session` is "on" and `sticky_session_type` is "server". Otherwise, it will be ignored. Valid value：String in line with RFC 2965, with length being 1- 200. It only contains characters such as ASCII codes, English letters and digits instead of the comma, semicolon or spacing, and it cannot start with $.
func (r *Listener) Cookie() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["cookie"])
}

// Cookie timeout. It is mandatory when `sticky_session` is "on" and `sticky_session_type` is "insert". Otherwise, it will be ignored. Valid value range: [1-86400] in seconds.
func (r *Listener) CookieTimeout() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["cookieTimeout"])
}

// Port used by the Server Load Balancer instance frontend. Valid value range: [1-65535].
func (r *Listener) FrontendPort() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["frontendPort"])
}

// Whether to enable "Gzip Compression". If enabled, files of specific file types will be compressed, otherwise, no files will be compressed. Default to true. Available in v1.13.0+.
func (r *Listener) Gzip() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["gzip"])
}

// Whether to enable health check. Valid values are`on` and `off`. TCP and UDP listener's HealthCheck is always on, so it will be ignore when launching TCP or UDP listener.
func (r *Listener) HealthCheck() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["healthCheck"])
}

// Port used for health check. Valid value range: [1-65535]. Default to "None" means the backend server port is used.
func (r *Listener) HealthCheckConnectPort() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["healthCheckConnectPort"])
}

// Domain name used for health check. When it used to launch TCP listener, `health_check_type` must be "http". Its length is limited to 1-80 and only characters such as letters, digits, ‘-‘ and ‘.’ are allowed. When it is not set or empty,  Server Load Balancer uses the private network IP address of each backend server as Domain used for health check.
func (r *Listener) HealthCheckDomain() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["healthCheckDomain"])
}

// Regular health check HTTP status code. Multiple codes are segmented by “,”. It is required when `health_check` is on. Default to `http_2xx`.  Valid values are: `http_2xx`,  `http_3xx`, `http_4xx` and `http_5xx`.
func (r *Listener) HealthCheckHttpCode() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["healthCheckHttpCode"])
}

// Time interval of health checks. It is required when `health_check` is on. Valid value range: [1-50] in seconds. Default to 2.
func (r *Listener) HealthCheckInterval() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["healthCheckInterval"])
}

// Maximum timeout of each health check response. It is required when `health_check` is on. Valid value range: [1-300] in seconds. Default to 5. Note: If `health_check_timeout` < `health_check_interval`, its will be replaced by `health_check_interval`.
func (r *Listener) HealthCheckTimeout() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["healthCheckTimeout"])
}

// Type of health check. Valid values are: `tcp` and `http`. Default to `tcp` . TCP supports TCP and HTTP health check mode, you can select the particular mode depending on your application.
func (r *Listener) HealthCheckType() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["healthCheckType"])
}

// URI used for health check. When it used to launch TCP listener, `health_check_type` must be "http". Its length is limited to 1-80 and it must start with /. Only characters such as letters, digits, ‘-’, ‘/’, ‘.’, ‘%’, ‘?’, #’ and ‘&’ are allowed.
func (r *Listener) HealthCheckUri() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["healthCheckUri"])
}

// Threshold determining the result of the health check is success. It is required when `health_check` is on. Valid value range: [1-10] in seconds. Default to 3.
func (r *Listener) HealthyThreshold() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["healthyThreshold"])
}

func (r *Listener) InstancePort() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["instancePort"])
}

func (r *Listener) LbPort() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["lbPort"])
}

func (r *Listener) LbProtocol() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["lbProtocol"])
}

// The Load Balancer ID which is used to launch a new listener.
func (r *Listener) LoadBalancerId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["loadBalancerId"])
}

// Timeout of connection persistence. Valid value range: [0-3600] in seconds. Default to 0 and means closing it.
func (r *Listener) PersistenceTimeout() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["persistenceTimeout"])
}

// The protocol to listen on. Valid values are [`http`, `https`, `tcp`, `udp`].
func (r *Listener) Protocol() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["protocol"])
}

// Scheduling algorithm, Valid values are `wrr` and `wlc`.  Default to "wrr".
func (r *Listener) Scheduler() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["scheduler"])
}

func (r *Listener) ServerGroupId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["serverGroupId"])
}

// Security certificate ID. It is required when `protocol` is `https`.
func (r *Listener) SslCertificateId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["sslCertificateId"])
}

// Whether to enable session persistence, Valid values are `on` and `off`. Default to `off`.
func (r *Listener) StickySession() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["stickySession"])
}

// Mode for handling the cookie. If `sticky_session` is "on", it is mandatory. Otherwise, it will be ignored. Valid values are `insert` and `server`. `insert` means it is inserted from Server Load Balancer; `server` means the Server Load Balancer learns from the backend server.
func (r *Listener) StickySessionType() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["stickySessionType"])
}

// Threshold determining the result of the health check is fail. It is required when `health_check` is on. Valid value range: [1-10] in seconds. Default to 3.
func (r *Listener) UnhealthyThreshold() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["unhealthyThreshold"])
}

// Whether to set additional HTTP Header field "X-Forwarded-For" (documented below). Available in v1.13.0+.
func (r *Listener) XForwardedFor() *pulumi.Output {
	return r.s.State["xForwardedFor"]
}

// Input properties used for looking up and filtering Listener resources.
type ListenerState struct {
	// the id of access control list to be apply on the listener, is the id of resource alicloud_slb_acl. If `acl_status` is "on", it is mandatory. Otherwise, it will be ignored.
	AclId interface{}
	// Whether to enable "acl(access control list)", the acl is specified by `acl_id`. Valid values are `on` and `off`. Default to `off`.
	AclStatus interface{}
	// Mode for handling the acl specified by acl_id. If `acl_status` is "on", it is mandatory. Otherwise, it will be ignored. Valid values are `white` and `black`. `white` means the Listener can only be accessed by client ip belongs to the acl; `black` means the Listener can not be accessed by client ip belongs to the acl;
	AclType interface{}
	// Port used by the Server Load Balancer instance backend. Valid value range: [1-65535].
	BackendPort interface{}
	// Bandwidth peak of Listener. For the public network instance charged per traffic consumed, the Bandwidth on Listener can be set to -1, indicating the bandwidth peak is unlimited. Valid values are [-1, 1-1000] in Mbps.
	Bandwidth interface{}
	// The cookie configured on the server. It is mandatory when `sticky_session` is "on" and `sticky_session_type` is "server". Otherwise, it will be ignored. Valid value：String in line with RFC 2965, with length being 1- 200. It only contains characters such as ASCII codes, English letters and digits instead of the comma, semicolon or spacing, and it cannot start with $.
	Cookie interface{}
	// Cookie timeout. It is mandatory when `sticky_session` is "on" and `sticky_session_type` is "insert". Otherwise, it will be ignored. Valid value range: [1-86400] in seconds.
	CookieTimeout interface{}
	// Port used by the Server Load Balancer instance frontend. Valid value range: [1-65535].
	FrontendPort interface{}
	// Whether to enable "Gzip Compression". If enabled, files of specific file types will be compressed, otherwise, no files will be compressed. Default to true. Available in v1.13.0+.
	Gzip interface{}
	// Whether to enable health check. Valid values are`on` and `off`. TCP and UDP listener's HealthCheck is always on, so it will be ignore when launching TCP or UDP listener.
	HealthCheck interface{}
	// Port used for health check. Valid value range: [1-65535]. Default to "None" means the backend server port is used.
	HealthCheckConnectPort interface{}
	// Domain name used for health check. When it used to launch TCP listener, `health_check_type` must be "http". Its length is limited to 1-80 and only characters such as letters, digits, ‘-‘ and ‘.’ are allowed. When it is not set or empty,  Server Load Balancer uses the private network IP address of each backend server as Domain used for health check.
	HealthCheckDomain interface{}
	// Regular health check HTTP status code. Multiple codes are segmented by “,”. It is required when `health_check` is on. Default to `http_2xx`.  Valid values are: `http_2xx`,  `http_3xx`, `http_4xx` and `http_5xx`.
	HealthCheckHttpCode interface{}
	// Time interval of health checks. It is required when `health_check` is on. Valid value range: [1-50] in seconds. Default to 2.
	HealthCheckInterval interface{}
	// Maximum timeout of each health check response. It is required when `health_check` is on. Valid value range: [1-300] in seconds. Default to 5. Note: If `health_check_timeout` < `health_check_interval`, its will be replaced by `health_check_interval`.
	HealthCheckTimeout interface{}
	// Type of health check. Valid values are: `tcp` and `http`. Default to `tcp` . TCP supports TCP and HTTP health check mode, you can select the particular mode depending on your application.
	HealthCheckType interface{}
	// URI used for health check. When it used to launch TCP listener, `health_check_type` must be "http". Its length is limited to 1-80 and it must start with /. Only characters such as letters, digits, ‘-’, ‘/’, ‘.’, ‘%’, ‘?’, #’ and ‘&’ are allowed.
	HealthCheckUri interface{}
	// Threshold determining the result of the health check is success. It is required when `health_check` is on. Valid value range: [1-10] in seconds. Default to 3.
	HealthyThreshold interface{}
	InstancePort interface{}
	LbPort interface{}
	LbProtocol interface{}
	// The Load Balancer ID which is used to launch a new listener.
	LoadBalancerId interface{}
	// Timeout of connection persistence. Valid value range: [0-3600] in seconds. Default to 0 and means closing it.
	PersistenceTimeout interface{}
	// The protocol to listen on. Valid values are [`http`, `https`, `tcp`, `udp`].
	Protocol interface{}
	// Scheduling algorithm, Valid values are `wrr` and `wlc`.  Default to "wrr".
	Scheduler interface{}
	ServerGroupId interface{}
	// Security certificate ID. It is required when `protocol` is `https`.
	SslCertificateId interface{}
	// Whether to enable session persistence, Valid values are `on` and `off`. Default to `off`.
	StickySession interface{}
	// Mode for handling the cookie. If `sticky_session` is "on", it is mandatory. Otherwise, it will be ignored. Valid values are `insert` and `server`. `insert` means it is inserted from Server Load Balancer; `server` means the Server Load Balancer learns from the backend server.
	StickySessionType interface{}
	// Threshold determining the result of the health check is fail. It is required when `health_check` is on. Valid value range: [1-10] in seconds. Default to 3.
	UnhealthyThreshold interface{}
	// Whether to set additional HTTP Header field "X-Forwarded-For" (documented below). Available in v1.13.0+.
	XForwardedFor interface{}
}

// The set of arguments for constructing a Listener resource.
type ListenerArgs struct {
	// the id of access control list to be apply on the listener, is the id of resource alicloud_slb_acl. If `acl_status` is "on", it is mandatory. Otherwise, it will be ignored.
	AclId interface{}
	// Whether to enable "acl(access control list)", the acl is specified by `acl_id`. Valid values are `on` and `off`. Default to `off`.
	AclStatus interface{}
	// Mode for handling the acl specified by acl_id. If `acl_status` is "on", it is mandatory. Otherwise, it will be ignored. Valid values are `white` and `black`. `white` means the Listener can only be accessed by client ip belongs to the acl; `black` means the Listener can not be accessed by client ip belongs to the acl;
	AclType interface{}
	// Port used by the Server Load Balancer instance backend. Valid value range: [1-65535].
	BackendPort interface{}
	// Bandwidth peak of Listener. For the public network instance charged per traffic consumed, the Bandwidth on Listener can be set to -1, indicating the bandwidth peak is unlimited. Valid values are [-1, 1-1000] in Mbps.
	Bandwidth interface{}
	// The cookie configured on the server. It is mandatory when `sticky_session` is "on" and `sticky_session_type` is "server". Otherwise, it will be ignored. Valid value：String in line with RFC 2965, with length being 1- 200. It only contains characters such as ASCII codes, English letters and digits instead of the comma, semicolon or spacing, and it cannot start with $.
	Cookie interface{}
	// Cookie timeout. It is mandatory when `sticky_session` is "on" and `sticky_session_type` is "insert". Otherwise, it will be ignored. Valid value range: [1-86400] in seconds.
	CookieTimeout interface{}
	// Port used by the Server Load Balancer instance frontend. Valid value range: [1-65535].
	FrontendPort interface{}
	// Whether to enable "Gzip Compression". If enabled, files of specific file types will be compressed, otherwise, no files will be compressed. Default to true. Available in v1.13.0+.
	Gzip interface{}
	// Whether to enable health check. Valid values are`on` and `off`. TCP and UDP listener's HealthCheck is always on, so it will be ignore when launching TCP or UDP listener.
	HealthCheck interface{}
	// Port used for health check. Valid value range: [1-65535]. Default to "None" means the backend server port is used.
	HealthCheckConnectPort interface{}
	// Domain name used for health check. When it used to launch TCP listener, `health_check_type` must be "http". Its length is limited to 1-80 and only characters such as letters, digits, ‘-‘ and ‘.’ are allowed. When it is not set or empty,  Server Load Balancer uses the private network IP address of each backend server as Domain used for health check.
	HealthCheckDomain interface{}
	// Regular health check HTTP status code. Multiple codes are segmented by “,”. It is required when `health_check` is on. Default to `http_2xx`.  Valid values are: `http_2xx`,  `http_3xx`, `http_4xx` and `http_5xx`.
	HealthCheckHttpCode interface{}
	// Time interval of health checks. It is required when `health_check` is on. Valid value range: [1-50] in seconds. Default to 2.
	HealthCheckInterval interface{}
	// Maximum timeout of each health check response. It is required when `health_check` is on. Valid value range: [1-300] in seconds. Default to 5. Note: If `health_check_timeout` < `health_check_interval`, its will be replaced by `health_check_interval`.
	HealthCheckTimeout interface{}
	// Type of health check. Valid values are: `tcp` and `http`. Default to `tcp` . TCP supports TCP and HTTP health check mode, you can select the particular mode depending on your application.
	HealthCheckType interface{}
	// URI used for health check. When it used to launch TCP listener, `health_check_type` must be "http". Its length is limited to 1-80 and it must start with /. Only characters such as letters, digits, ‘-’, ‘/’, ‘.’, ‘%’, ‘?’, #’ and ‘&’ are allowed.
	HealthCheckUri interface{}
	// Threshold determining the result of the health check is success. It is required when `health_check` is on. Valid value range: [1-10] in seconds. Default to 3.
	HealthyThreshold interface{}
	InstancePort interface{}
	LbPort interface{}
	LbProtocol interface{}
	// The Load Balancer ID which is used to launch a new listener.
	LoadBalancerId interface{}
	// Timeout of connection persistence. Valid value range: [0-3600] in seconds. Default to 0 and means closing it.
	PersistenceTimeout interface{}
	// The protocol to listen on. Valid values are [`http`, `https`, `tcp`, `udp`].
	Protocol interface{}
	// Scheduling algorithm, Valid values are `wrr` and `wlc`.  Default to "wrr".
	Scheduler interface{}
	ServerGroupId interface{}
	// Security certificate ID. It is required when `protocol` is `https`.
	SslCertificateId interface{}
	// Whether to enable session persistence, Valid values are `on` and `off`. Default to `off`.
	StickySession interface{}
	// Mode for handling the cookie. If `sticky_session` is "on", it is mandatory. Otherwise, it will be ignored. Valid values are `insert` and `server`. `insert` means it is inserted from Server Load Balancer; `server` means the Server Load Balancer learns from the backend server.
	StickySessionType interface{}
	// Threshold determining the result of the health check is fail. It is required when `health_check` is on. Valid value range: [1-10] in seconds. Default to 3.
	UnhealthyThreshold interface{}
	// Whether to set additional HTTP Header field "X-Forwarded-For" (documented below). Available in v1.13.0+.
	XForwardedFor interface{}
}
