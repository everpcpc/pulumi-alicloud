// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package hbr

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a HBR Oss Backup Plan resource.
//
// For information about HBR Oss Backup Plan and how to use it, see [What is Oss Backup Plan](https://www.alibabacloud.com/product/hybrid-backup-recovery).
//
// > **NOTE:** Available in v1.131.0+.
//
// ## Example Usage
//
// Basic Usage
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/hbr"
// 	"github.com/pulumi/pulumi-alicloud/sdk/v3/go/alicloud/oss"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		cfg := config.New(ctx, "")
// 		name := fmt.Sprintf("%v%v", "%", "s")
// 		if param := cfg.Get("name"); param != "" {
// 			name = param
// 		}
// 		defaultVault, err := hbr.NewVault(ctx, "defaultVault", &hbr.VaultArgs{
// 			VaultName: pulumi.String(name),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		opt0 := "bosh-cf-blobstore-hz"
// 		_, err = oss.GetBuckets(ctx, &oss.GetBucketsArgs{
// 			NameRegex: &opt0,
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		_, err = hbr.NewOssBackupPlan(ctx, "example", &hbr.OssBackupPlanArgs{
// 			OssBackupPlanName: pulumi.String(name),
// 			VaultId:           defaultVault.ID(),
// 			Bucket:            pulumi.Any(alicloud_oss_bucket.Default.Bucket),
// 			Prefix:            pulumi.String("/home"),
// 			Retention:         pulumi.String("1"),
// 			Schedule:          pulumi.String("I|1602673264|PT2H"),
// 			BackupType:        pulumi.String("COMPLETE"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// HBR Oss Backup Plan can be imported using the id, e.g.
//
// ```sh
//  $ pulumi import alicloud:hbr/ossBackupPlan:OssBackupPlan example <id>
// ```
type OssBackupPlan struct {
	pulumi.CustomResourceState

	// Backup Type. Valid Values: * Complete. Valid values: `COMPLETE`.
	BackupType pulumi.StringOutput `pulumi:"backupType"`
	// The OSS Bucket Name.
	Bucket pulumi.StringPtrOutput `pulumi:"bucket"`
	// Whether to Disable the Backup Task. Valid Values: true, false.
	Disabled pulumi.BoolOutput `pulumi:"disabled"`
	// The Configuration Page of a Backup Plan Name. 1-64 Characters, requiring a Single Warehouse under Each of the Data Source Type Drop-down List of the Configuration Page of a Backup Plan Name Is Unique.
	OssBackupPlanName pulumi.StringOutput    `pulumi:"ossBackupPlanName"`
	Prefix            pulumi.StringPtrOutput `pulumi:"prefix"`
	// Backup Retention Period, the Minimum Value of 1.
	Retention pulumi.StringOutput `pulumi:"retention"`
	// Backup strategy. Optional format: I|{startTime}|{interval} * startTime Backup start time, UNIX time, in seconds. * interval ISO8601 time interval. E.g: ** PT1H, one hour apart. ** P1D, one day apart. It means to execute a backup task every {interval} starting from {startTime}. The backup task for the elapsed time will not be compensated. If the last backup task is not completed, the next backup task will not be triggered.
	Schedule pulumi.StringOutput `pulumi:"schedule"`
	// Vault ID.
	VaultId pulumi.StringPtrOutput `pulumi:"vaultId"`
}

// NewOssBackupPlan registers a new resource with the given unique name, arguments, and options.
func NewOssBackupPlan(ctx *pulumi.Context,
	name string, args *OssBackupPlanArgs, opts ...pulumi.ResourceOption) (*OssBackupPlan, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.OssBackupPlanName == nil {
		return nil, errors.New("invalid value for required argument 'OssBackupPlanName'")
	}
	if args.Retention == nil {
		return nil, errors.New("invalid value for required argument 'Retention'")
	}
	if args.Schedule == nil {
		return nil, errors.New("invalid value for required argument 'Schedule'")
	}
	var resource OssBackupPlan
	err := ctx.RegisterResource("alicloud:hbr/ossBackupPlan:OssBackupPlan", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetOssBackupPlan gets an existing OssBackupPlan resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetOssBackupPlan(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *OssBackupPlanState, opts ...pulumi.ResourceOption) (*OssBackupPlan, error) {
	var resource OssBackupPlan
	err := ctx.ReadResource("alicloud:hbr/ossBackupPlan:OssBackupPlan", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering OssBackupPlan resources.
type ossBackupPlanState struct {
	// Backup Type. Valid Values: * Complete. Valid values: `COMPLETE`.
	BackupType *string `pulumi:"backupType"`
	// The OSS Bucket Name.
	Bucket *string `pulumi:"bucket"`
	// Whether to Disable the Backup Task. Valid Values: true, false.
	Disabled *bool `pulumi:"disabled"`
	// The Configuration Page of a Backup Plan Name. 1-64 Characters, requiring a Single Warehouse under Each of the Data Source Type Drop-down List of the Configuration Page of a Backup Plan Name Is Unique.
	OssBackupPlanName *string `pulumi:"ossBackupPlanName"`
	Prefix            *string `pulumi:"prefix"`
	// Backup Retention Period, the Minimum Value of 1.
	Retention *string `pulumi:"retention"`
	// Backup strategy. Optional format: I|{startTime}|{interval} * startTime Backup start time, UNIX time, in seconds. * interval ISO8601 time interval. E.g: ** PT1H, one hour apart. ** P1D, one day apart. It means to execute a backup task every {interval} starting from {startTime}. The backup task for the elapsed time will not be compensated. If the last backup task is not completed, the next backup task will not be triggered.
	Schedule *string `pulumi:"schedule"`
	// Vault ID.
	VaultId *string `pulumi:"vaultId"`
}

type OssBackupPlanState struct {
	// Backup Type. Valid Values: * Complete. Valid values: `COMPLETE`.
	BackupType pulumi.StringPtrInput
	// The OSS Bucket Name.
	Bucket pulumi.StringPtrInput
	// Whether to Disable the Backup Task. Valid Values: true, false.
	Disabled pulumi.BoolPtrInput
	// The Configuration Page of a Backup Plan Name. 1-64 Characters, requiring a Single Warehouse under Each of the Data Source Type Drop-down List of the Configuration Page of a Backup Plan Name Is Unique.
	OssBackupPlanName pulumi.StringPtrInput
	Prefix            pulumi.StringPtrInput
	// Backup Retention Period, the Minimum Value of 1.
	Retention pulumi.StringPtrInput
	// Backup strategy. Optional format: I|{startTime}|{interval} * startTime Backup start time, UNIX time, in seconds. * interval ISO8601 time interval. E.g: ** PT1H, one hour apart. ** P1D, one day apart. It means to execute a backup task every {interval} starting from {startTime}. The backup task for the elapsed time will not be compensated. If the last backup task is not completed, the next backup task will not be triggered.
	Schedule pulumi.StringPtrInput
	// Vault ID.
	VaultId pulumi.StringPtrInput
}

func (OssBackupPlanState) ElementType() reflect.Type {
	return reflect.TypeOf((*ossBackupPlanState)(nil)).Elem()
}

type ossBackupPlanArgs struct {
	// Backup Type. Valid Values: * Complete. Valid values: `COMPLETE`.
	BackupType *string `pulumi:"backupType"`
	// The OSS Bucket Name.
	Bucket *string `pulumi:"bucket"`
	// Whether to Disable the Backup Task. Valid Values: true, false.
	Disabled *bool `pulumi:"disabled"`
	// The Configuration Page of a Backup Plan Name. 1-64 Characters, requiring a Single Warehouse under Each of the Data Source Type Drop-down List of the Configuration Page of a Backup Plan Name Is Unique.
	OssBackupPlanName string  `pulumi:"ossBackupPlanName"`
	Prefix            *string `pulumi:"prefix"`
	// Backup Retention Period, the Minimum Value of 1.
	Retention string `pulumi:"retention"`
	// Backup strategy. Optional format: I|{startTime}|{interval} * startTime Backup start time, UNIX time, in seconds. * interval ISO8601 time interval. E.g: ** PT1H, one hour apart. ** P1D, one day apart. It means to execute a backup task every {interval} starting from {startTime}. The backup task for the elapsed time will not be compensated. If the last backup task is not completed, the next backup task will not be triggered.
	Schedule string `pulumi:"schedule"`
	// Vault ID.
	VaultId *string `pulumi:"vaultId"`
}

// The set of arguments for constructing a OssBackupPlan resource.
type OssBackupPlanArgs struct {
	// Backup Type. Valid Values: * Complete. Valid values: `COMPLETE`.
	BackupType pulumi.StringPtrInput
	// The OSS Bucket Name.
	Bucket pulumi.StringPtrInput
	// Whether to Disable the Backup Task. Valid Values: true, false.
	Disabled pulumi.BoolPtrInput
	// The Configuration Page of a Backup Plan Name. 1-64 Characters, requiring a Single Warehouse under Each of the Data Source Type Drop-down List of the Configuration Page of a Backup Plan Name Is Unique.
	OssBackupPlanName pulumi.StringInput
	Prefix            pulumi.StringPtrInput
	// Backup Retention Period, the Minimum Value of 1.
	Retention pulumi.StringInput
	// Backup strategy. Optional format: I|{startTime}|{interval} * startTime Backup start time, UNIX time, in seconds. * interval ISO8601 time interval. E.g: ** PT1H, one hour apart. ** P1D, one day apart. It means to execute a backup task every {interval} starting from {startTime}. The backup task for the elapsed time will not be compensated. If the last backup task is not completed, the next backup task will not be triggered.
	Schedule pulumi.StringInput
	// Vault ID.
	VaultId pulumi.StringPtrInput
}

func (OssBackupPlanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ossBackupPlanArgs)(nil)).Elem()
}

type OssBackupPlanInput interface {
	pulumi.Input

	ToOssBackupPlanOutput() OssBackupPlanOutput
	ToOssBackupPlanOutputWithContext(ctx context.Context) OssBackupPlanOutput
}

func (*OssBackupPlan) ElementType() reflect.Type {
	return reflect.TypeOf((*OssBackupPlan)(nil))
}

func (i *OssBackupPlan) ToOssBackupPlanOutput() OssBackupPlanOutput {
	return i.ToOssBackupPlanOutputWithContext(context.Background())
}

func (i *OssBackupPlan) ToOssBackupPlanOutputWithContext(ctx context.Context) OssBackupPlanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OssBackupPlanOutput)
}

func (i *OssBackupPlan) ToOssBackupPlanPtrOutput() OssBackupPlanPtrOutput {
	return i.ToOssBackupPlanPtrOutputWithContext(context.Background())
}

func (i *OssBackupPlan) ToOssBackupPlanPtrOutputWithContext(ctx context.Context) OssBackupPlanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OssBackupPlanPtrOutput)
}

type OssBackupPlanPtrInput interface {
	pulumi.Input

	ToOssBackupPlanPtrOutput() OssBackupPlanPtrOutput
	ToOssBackupPlanPtrOutputWithContext(ctx context.Context) OssBackupPlanPtrOutput
}

type ossBackupPlanPtrType OssBackupPlanArgs

func (*ossBackupPlanPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OssBackupPlan)(nil))
}

func (i *ossBackupPlanPtrType) ToOssBackupPlanPtrOutput() OssBackupPlanPtrOutput {
	return i.ToOssBackupPlanPtrOutputWithContext(context.Background())
}

func (i *ossBackupPlanPtrType) ToOssBackupPlanPtrOutputWithContext(ctx context.Context) OssBackupPlanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OssBackupPlanPtrOutput)
}

// OssBackupPlanArrayInput is an input type that accepts OssBackupPlanArray and OssBackupPlanArrayOutput values.
// You can construct a concrete instance of `OssBackupPlanArrayInput` via:
//
//          OssBackupPlanArray{ OssBackupPlanArgs{...} }
type OssBackupPlanArrayInput interface {
	pulumi.Input

	ToOssBackupPlanArrayOutput() OssBackupPlanArrayOutput
	ToOssBackupPlanArrayOutputWithContext(context.Context) OssBackupPlanArrayOutput
}

type OssBackupPlanArray []OssBackupPlanInput

func (OssBackupPlanArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*OssBackupPlan)(nil))
}

func (i OssBackupPlanArray) ToOssBackupPlanArrayOutput() OssBackupPlanArrayOutput {
	return i.ToOssBackupPlanArrayOutputWithContext(context.Background())
}

func (i OssBackupPlanArray) ToOssBackupPlanArrayOutputWithContext(ctx context.Context) OssBackupPlanArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OssBackupPlanArrayOutput)
}

// OssBackupPlanMapInput is an input type that accepts OssBackupPlanMap and OssBackupPlanMapOutput values.
// You can construct a concrete instance of `OssBackupPlanMapInput` via:
//
//          OssBackupPlanMap{ "key": OssBackupPlanArgs{...} }
type OssBackupPlanMapInput interface {
	pulumi.Input

	ToOssBackupPlanMapOutput() OssBackupPlanMapOutput
	ToOssBackupPlanMapOutputWithContext(context.Context) OssBackupPlanMapOutput
}

type OssBackupPlanMap map[string]OssBackupPlanInput

func (OssBackupPlanMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*OssBackupPlan)(nil))
}

func (i OssBackupPlanMap) ToOssBackupPlanMapOutput() OssBackupPlanMapOutput {
	return i.ToOssBackupPlanMapOutputWithContext(context.Background())
}

func (i OssBackupPlanMap) ToOssBackupPlanMapOutputWithContext(ctx context.Context) OssBackupPlanMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OssBackupPlanMapOutput)
}

type OssBackupPlanOutput struct {
	*pulumi.OutputState
}

func (OssBackupPlanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OssBackupPlan)(nil))
}

func (o OssBackupPlanOutput) ToOssBackupPlanOutput() OssBackupPlanOutput {
	return o
}

func (o OssBackupPlanOutput) ToOssBackupPlanOutputWithContext(ctx context.Context) OssBackupPlanOutput {
	return o
}

func (o OssBackupPlanOutput) ToOssBackupPlanPtrOutput() OssBackupPlanPtrOutput {
	return o.ToOssBackupPlanPtrOutputWithContext(context.Background())
}

func (o OssBackupPlanOutput) ToOssBackupPlanPtrOutputWithContext(ctx context.Context) OssBackupPlanPtrOutput {
	return o.ApplyT(func(v OssBackupPlan) *OssBackupPlan {
		return &v
	}).(OssBackupPlanPtrOutput)
}

type OssBackupPlanPtrOutput struct {
	*pulumi.OutputState
}

func (OssBackupPlanPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OssBackupPlan)(nil))
}

func (o OssBackupPlanPtrOutput) ToOssBackupPlanPtrOutput() OssBackupPlanPtrOutput {
	return o
}

func (o OssBackupPlanPtrOutput) ToOssBackupPlanPtrOutputWithContext(ctx context.Context) OssBackupPlanPtrOutput {
	return o
}

type OssBackupPlanArrayOutput struct{ *pulumi.OutputState }

func (OssBackupPlanArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OssBackupPlan)(nil))
}

func (o OssBackupPlanArrayOutput) ToOssBackupPlanArrayOutput() OssBackupPlanArrayOutput {
	return o
}

func (o OssBackupPlanArrayOutput) ToOssBackupPlanArrayOutputWithContext(ctx context.Context) OssBackupPlanArrayOutput {
	return o
}

func (o OssBackupPlanArrayOutput) Index(i pulumi.IntInput) OssBackupPlanOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OssBackupPlan {
		return vs[0].([]OssBackupPlan)[vs[1].(int)]
	}).(OssBackupPlanOutput)
}

type OssBackupPlanMapOutput struct{ *pulumi.OutputState }

func (OssBackupPlanMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]OssBackupPlan)(nil))
}

func (o OssBackupPlanMapOutput) ToOssBackupPlanMapOutput() OssBackupPlanMapOutput {
	return o
}

func (o OssBackupPlanMapOutput) ToOssBackupPlanMapOutputWithContext(ctx context.Context) OssBackupPlanMapOutput {
	return o
}

func (o OssBackupPlanMapOutput) MapIndex(k pulumi.StringInput) OssBackupPlanOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) OssBackupPlan {
		return vs[0].(map[string]OssBackupPlan)[vs[1].(string)]
	}).(OssBackupPlanOutput)
}

func init() {
	pulumi.RegisterOutputType(OssBackupPlanOutput{})
	pulumi.RegisterOutputType(OssBackupPlanPtrOutput{})
	pulumi.RegisterOutputType(OssBackupPlanArrayOutput{})
	pulumi.RegisterOutputType(OssBackupPlanMapOutput{})
}
