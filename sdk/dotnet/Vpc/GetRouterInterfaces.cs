// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AliCloud.Vpc
{
    public static partial class Invokes
    {
        /// <summary>
        /// This data source provides information about [router interfaces](https://www.alibabacloud.com/help/doc-detail/52412.htm)
        /// that connect VPCs together.
        /// 
        /// 
        /// 
        /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-alicloud/blob/master/website/docs/d/router_interfaces.html.markdown.
        /// </summary>
        [Obsolete("Use GetRouterInterfaces.InvokeAsync() instead")]
        public static Task<GetRouterInterfacesResult> GetRouterInterfaces(GetRouterInterfacesArgs? args = null, InvokeOptions? options = null)
            => Pulumi.Deployment.Instance.InvokeAsync<GetRouterInterfacesResult>("alicloud:vpc/getRouterInterfaces:getRouterInterfaces", args ?? InvokeArgs.Empty, options.WithVersion());
    }
    public static class GetRouterInterfaces
    {
        /// <summary>
        /// This data source provides information about [router interfaces](https://www.alibabacloud.com/help/doc-detail/52412.htm)
        /// that connect VPCs together.
        /// 
        /// 
        /// 
        /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-alicloud/blob/master/website/docs/d/router_interfaces.html.markdown.
        /// </summary>
        public static Task<GetRouterInterfacesResult> InvokeAsync(GetRouterInterfacesArgs? args = null, InvokeOptions? options = null)
            => Pulumi.Deployment.Instance.InvokeAsync<GetRouterInterfacesResult>("alicloud:vpc/getRouterInterfaces:getRouterInterfaces", args ?? InvokeArgs.Empty, options.WithVersion());
    }

    public sealed class GetRouterInterfacesArgs : Pulumi.InvokeArgs
    {
        [Input("ids")]
        private List<string>? _ids;

        /// <summary>
        /// A list of router interface IDs.
        /// </summary>
        public List<string> Ids
        {
            get => _ids ?? (_ids = new List<string>());
            set => _ids = value;
        }

        /// <summary>
        /// A regex string used to filter by router interface name.
        /// </summary>
        [Input("nameRegex")]
        public string? NameRegex { get; set; }

        /// <summary>
        /// ID of the peer router interface.
        /// </summary>
        [Input("oppositeInterfaceId")]
        public string? OppositeInterfaceId { get; set; }

        /// <summary>
        /// Account ID of the owner of the peer router interface.
        /// </summary>
        [Input("oppositeInterfaceOwnerId")]
        public string? OppositeInterfaceOwnerId { get; set; }

        [Input("outputFile")]
        public string? OutputFile { get; set; }

        /// <summary>
        /// Role of the router interface. Valid values are `InitiatingSide` (connection initiator) and 
        /// `AcceptingSide` (connection receiver). The value of this parameter must be `InitiatingSide` if the `router_type` is set to `VBR`.
        /// </summary>
        [Input("role")]
        public string? Role { get; set; }

        /// <summary>
        /// ID of the VRouter located in the local region.
        /// </summary>
        [Input("routerId")]
        public string? RouterId { get; set; }

        /// <summary>
        /// Router type in the local region. Valid values are `VRouter` and `VBR` (physical connection).
        /// </summary>
        [Input("routerType")]
        public string? RouterType { get; set; }

        /// <summary>
        /// Specification of the link, such as `Small.1` (10Mb), `Middle.1` (100Mb), `Large.2` (2Gb), ...etc.
        /// </summary>
        [Input("specification")]
        public string? Specification { get; set; }

        /// <summary>
        /// Expected status. Valid values are `Active`, `Inactive` and `Idle`.
        /// </summary>
        [Input("status")]
        public string? Status { get; set; }

        public GetRouterInterfacesArgs()
        {
        }
    }

    [OutputType]
    public sealed class GetRouterInterfacesResult
    {
        /// <summary>
        /// A list of router interface IDs.
        /// </summary>
        public readonly ImmutableArray<string> Ids;
        /// <summary>
        /// A list of router interfaces. Each element contains the following attributes:
        /// </summary>
        public readonly ImmutableArray<Outputs.GetRouterInterfacesInterfacesResult> Interfaces;
        public readonly string? NameRegex;
        /// <summary>
        /// A list of router interface names.
        /// </summary>
        public readonly ImmutableArray<string> Names;
        /// <summary>
        /// Peer router interface ID.
        /// </summary>
        public readonly string? OppositeInterfaceId;
        /// <summary>
        /// Account ID of the owner of the peer router interface.
        /// </summary>
        public readonly string? OppositeInterfaceOwnerId;
        public readonly string? OutputFile;
        /// <summary>
        /// Router interface role. Possible values: `InitiatingSide` and `AcceptingSide`.
        /// </summary>
        public readonly string? Role;
        /// <summary>
        /// ID of the VRouter located in the local region.
        /// </summary>
        public readonly string? RouterId;
        /// <summary>
        /// Router type in the local region. Possible values: `VRouter` and `VBR`.
        /// </summary>
        public readonly string? RouterType;
        /// <summary>
        /// Router interface specification. Possible values: `Small.1`, `Middle.1`, `Large.2`, ...etc.
        /// </summary>
        public readonly string? Specification;
        /// <summary>
        /// Router interface status. Possible values: `Active`, `Inactive` and `Idle`.
        /// </summary>
        public readonly string? Status;
        /// <summary>
        /// id is the provider-assigned unique ID for this managed resource.
        /// </summary>
        public readonly string Id;

        [OutputConstructor]
        private GetRouterInterfacesResult(
            ImmutableArray<string> ids,
            ImmutableArray<Outputs.GetRouterInterfacesInterfacesResult> interfaces,
            string? nameRegex,
            ImmutableArray<string> names,
            string? oppositeInterfaceId,
            string? oppositeInterfaceOwnerId,
            string? outputFile,
            string? role,
            string? routerId,
            string? routerType,
            string? specification,
            string? status,
            string id)
        {
            Ids = ids;
            Interfaces = interfaces;
            NameRegex = nameRegex;
            Names = names;
            OppositeInterfaceId = oppositeInterfaceId;
            OppositeInterfaceOwnerId = oppositeInterfaceOwnerId;
            OutputFile = outputFile;
            Role = role;
            RouterId = routerId;
            RouterType = routerType;
            Specification = specification;
            Status = status;
            Id = id;
        }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class GetRouterInterfacesInterfacesResult
    {
        /// <summary>
        /// ID of the access point used by the VBR.
        /// </summary>
        public readonly string AccessPointId;
        /// <summary>
        /// Router interface creation time.
        /// </summary>
        public readonly string CreationTime;
        /// <summary>
        /// Router interface description.
        /// </summary>
        public readonly string Description;
        /// <summary>
        /// Source IP address used to perform health check on the physical connection.
        /// </summary>
        public readonly string HealthCheckSourceIp;
        /// <summary>
        /// Destination IP address used to perform health check on the physical connection.
        /// </summary>
        public readonly string HealthCheckTargetIp;
        /// <summary>
        /// Router interface ID.
        /// </summary>
        public readonly string Id;
        /// <summary>
        /// Router interface name.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// ID of the peer router interface.
        /// </summary>
        public readonly string OppositeInterfaceId;
        /// <summary>
        /// Account ID of the owner of the peer router interface.
        /// </summary>
        public readonly string OppositeInterfaceOwnerId;
        /// <summary>
        /// Peer router region ID.
        /// </summary>
        public readonly string OppositeRegionId;
        /// <summary>
        /// Peer router ID.
        /// </summary>
        public readonly string OppositeRouterId;
        /// <summary>
        /// Router type in the peer region. Possible values: `VRouter` and `VBR`.
        /// </summary>
        public readonly string OppositeRouterType;
        /// <summary>
        /// Role of the router interface. Valid values are `InitiatingSide` (connection initiator) and 
        /// `AcceptingSide` (connection receiver). The value of this parameter must be `InitiatingSide` if the `router_type` is set to `VBR`.
        /// </summary>
        public readonly string Role;
        /// <summary>
        /// ID of the VRouter located in the local region.
        /// </summary>
        public readonly string RouterId;
        /// <summary>
        /// Router type in the local region. Valid values are `VRouter` and `VBR` (physical connection).
        /// </summary>
        public readonly string RouterType;
        /// <summary>
        /// Specification of the link, such as `Small.1` (10Mb), `Middle.1` (100Mb), `Large.2` (2Gb), ...etc.
        /// </summary>
        public readonly string Specification;
        /// <summary>
        /// Expected status. Valid values are `Active`, `Inactive` and `Idle`.
        /// </summary>
        public readonly string Status;
        /// <summary>
        /// ID of the VPC that owns the router in the local region.
        /// </summary>
        public readonly string VpcId;

        [OutputConstructor]
        private GetRouterInterfacesInterfacesResult(
            string accessPointId,
            string creationTime,
            string description,
            string healthCheckSourceIp,
            string healthCheckTargetIp,
            string id,
            string name,
            string oppositeInterfaceId,
            string oppositeInterfaceOwnerId,
            string oppositeRegionId,
            string oppositeRouterId,
            string oppositeRouterType,
            string role,
            string routerId,
            string routerType,
            string specification,
            string status,
            string vpcId)
        {
            AccessPointId = accessPointId;
            CreationTime = creationTime;
            Description = description;
            HealthCheckSourceIp = healthCheckSourceIp;
            HealthCheckTargetIp = healthCheckTargetIp;
            Id = id;
            Name = name;
            OppositeInterfaceId = oppositeInterfaceId;
            OppositeInterfaceOwnerId = oppositeInterfaceOwnerId;
            OppositeRegionId = oppositeRegionId;
            OppositeRouterId = oppositeRouterId;
            OppositeRouterType = oppositeRouterType;
            Role = role;
            RouterId = routerId;
            RouterType = routerType;
            Specification = specification;
            Status = status;
            VpcId = vpcId;
        }
    }
    }
}
