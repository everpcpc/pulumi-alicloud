// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.alicloud.slb.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;

@CustomType
public final class GetListenersSlbListener {
    /**
     * @return Port opened on the backend server to receive requests.
     * 
     */
    private final Integer backendPort;
    /**
     * @return Peak bandwidth. If the value is set to -1, the listener is not limited by bandwidth.
     * 
     */
    private final Integer bandwidth;
    /**
     * @return ID of the CA certificate (only required when two-way authentication is used). Only available when the protocol is `https`.
     * 
     */
    private final String caCertificateId;
    /**
     * @return Cookie configured by the backend server. Only available when the sticky_session_type is `server`.
     * 
     */
    private final String cookie;
    /**
     * @return Cookie timeout in seconds. Only available when the sticky_session_type is `insert`.
     * 
     */
    private final Integer cookieTimeout;
    /**
     * @return The description of slb listener.
     * 
     */
    private final String description;
    /**
     * @return Whether to enable https listener support http2 or not. Valid values are `on` and `off`. Default to `on`.
     * 
     */
    private final String enableHttp2;
    /**
     * @return Connection timeout in seconds for the Layer 4 TCP listener. Only available when the protocol is `tcp`.
     * 
     */
    private final Integer establishedTimeout;
    /**
     * @return Filter listeners by the specified frontend port.
     * 
     */
    private final Integer frontendPort;
    /**
     * @return Indicate whether Gzip compression is enabled or not. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    private final String gzip;
    /**
     * @return Indicate whether health check is enabled of not. Possible values are `on` and `off`.
     * 
     */
    private final String healthCheck;
    /**
     * @return Port used for health check.
     * 
     */
    private final Integer healthCheckConnectPort;
    /**
     * @return Amount of time in seconds to wait for the response for a health check.
     * 
     */
    private final Integer healthCheckConnectTimeout;
    /**
     * @return Domain name used for health check. The SLB sends HTTP head requests to the backend server, the domain is useful when the backend server verifies the host field in the requests. Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
     * 
     */
    private final String healthCheckDomain;
    /**
     * @return HTTP status codes indicating that the health check is normal. It can contain several comma-separated values such as &#34;http_2xx,http_3xx&#34;. Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
     * 
     */
    private final String healthCheckHttpCode;
    /**
     * @return Time interval between two consecutive health checks.
     * 
     */
    private final Integer healthCheckInterval;
    /**
     * @return Amount of time in seconds to wait for the response from a health check. If an ECS instance sends no response within the specified timeout period, the health check fails. Only available when the protocol is `http` or `https`.
     * 
     */
    private final Integer healthCheckTimeout;
    /**
     * @return Health check method. Possible values are `tcp` and `http`. Only available when the protocol is `tcp`.
     * 
     */
    private final String healthCheckType;
    /**
     * @return URI used for health check. Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
     * 
     */
    private final String healthCheckUri;
    /**
     * @return Number of consecutive successes of health check performed on the same ECS instance (from failure to success).
     * 
     */
    private final Integer healthyThreshold;
    /**
     * @return Timeout of http or https listener established connection idle timeout. Valid value range: [1-60] in seconds. Default to 15.
     * 
     */
    private final Integer idleTimeout;
    /**
     * @return ID of the active/standby server group.
     * 
     */
    private final String masterSlaveServerGroupId;
    /**
     * @return Timeout value of the TCP connection in seconds. If the value is 0, the session persistence function is disabled. Only available when the protocol is `tcp`.
     * 
     */
    private final Integer persistenceTimeout;
    /**
     * @return Filter listeners by the specified protocol. Valid values: `http`, `https`, `tcp` and `udp`.
     * 
     */
    private final String protocol;
    /**
     * @return Timeout of http or https listener request (which does not get response from backend) timeout. Valid value range: [1-180] in seconds. Default to 60.
     * 
     */
    private final Integer requestTimeout;
    /**
     * @return Algorithm used to distribute traffic. Possible values: `wrr` (weighted round robin), `wlc` (weighted least connection) and `rr` (round robin).
     * 
     */
    private final String scheduler;
    /**
     * @return Security status. Only available when the protocol is `https`.
     * 
     */
    private final String securityStatus;
    private final String serverCertificateId;
    /**
     * @return ID of the linked VServer group.
     * 
     */
    private final String serverGroupId;
    /**
     * @return ID of the server certificate. Only available when the protocol is `https`.
     * 
     */
    private final String sslCertificateId;
    /**
     * @return Listener status.
     * 
     */
    private final String status;
    /**
     * @return Indicate whether session persistence is enabled or not. If enabled, all session requests from the same client are sent to the same backend server. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    private final String stickySession;
    /**
     * @return Method used to handle the cookie. Possible values are `insert` (cookie added to the response) and `server` (cookie set by the backend server). Only available when the protocol is `http` or `https` and sticky_session is `on`.
     * 
     */
    private final String stickySessionType;
    /**
     * @return Https listener TLS cipher policy. Valid values are `tls_cipher_policy_1_0`, `tls_cipher_policy_1_1`, `tls_cipher_policy_1_2`, `tls_cipher_policy_1_2_strict`. Default to `tls_cipher_policy_1_0`.
     * 
     */
    private final String tlsCipherPolicy;
    /**
     * @return Number of consecutive failures of health check performed on the same ECS instance (from success to failure).
     * 
     */
    private final Integer unhealthyThreshold;
    /**
     * @return Indicate whether the HTTP header field &#34;X-Forwarded-For&#34; is added or not; it allows the backend server to know about the user&#39;s IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    private final String xForwardedFor;
    /**
     * @return Indicate whether the HTTP header field &#34;X-Forwarded-For_SLBID&#34; is added or not; it allows the backend server to know about the SLB ID. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    private final String xForwardedForSlbId;
    /**
     * @return Indicate whether the HTTP header field &#34;X-Forwarded-For_SLBIP&#34; is added or not; it allows the backend server to know about the SLB IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    private final String xForwardedForSlbIp;
    /**
     * @return Indicate whether the HTTP header field &#34;X-Forwarded-For_proto&#34; is added or not; it allows the backend server to know about the user&#39;s protocol. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    private final String xForwardedForSlbProto;

    @CustomType.Constructor
    private GetListenersSlbListener(
        @CustomType.Parameter("backendPort") Integer backendPort,
        @CustomType.Parameter("bandwidth") Integer bandwidth,
        @CustomType.Parameter("caCertificateId") String caCertificateId,
        @CustomType.Parameter("cookie") String cookie,
        @CustomType.Parameter("cookieTimeout") Integer cookieTimeout,
        @CustomType.Parameter("description") String description,
        @CustomType.Parameter("enableHttp2") String enableHttp2,
        @CustomType.Parameter("establishedTimeout") Integer establishedTimeout,
        @CustomType.Parameter("frontendPort") Integer frontendPort,
        @CustomType.Parameter("gzip") String gzip,
        @CustomType.Parameter("healthCheck") String healthCheck,
        @CustomType.Parameter("healthCheckConnectPort") Integer healthCheckConnectPort,
        @CustomType.Parameter("healthCheckConnectTimeout") Integer healthCheckConnectTimeout,
        @CustomType.Parameter("healthCheckDomain") String healthCheckDomain,
        @CustomType.Parameter("healthCheckHttpCode") String healthCheckHttpCode,
        @CustomType.Parameter("healthCheckInterval") Integer healthCheckInterval,
        @CustomType.Parameter("healthCheckTimeout") Integer healthCheckTimeout,
        @CustomType.Parameter("healthCheckType") String healthCheckType,
        @CustomType.Parameter("healthCheckUri") String healthCheckUri,
        @CustomType.Parameter("healthyThreshold") Integer healthyThreshold,
        @CustomType.Parameter("idleTimeout") Integer idleTimeout,
        @CustomType.Parameter("masterSlaveServerGroupId") String masterSlaveServerGroupId,
        @CustomType.Parameter("persistenceTimeout") Integer persistenceTimeout,
        @CustomType.Parameter("protocol") String protocol,
        @CustomType.Parameter("requestTimeout") Integer requestTimeout,
        @CustomType.Parameter("scheduler") String scheduler,
        @CustomType.Parameter("securityStatus") String securityStatus,
        @CustomType.Parameter("serverCertificateId") String serverCertificateId,
        @CustomType.Parameter("serverGroupId") String serverGroupId,
        @CustomType.Parameter("sslCertificateId") String sslCertificateId,
        @CustomType.Parameter("status") String status,
        @CustomType.Parameter("stickySession") String stickySession,
        @CustomType.Parameter("stickySessionType") String stickySessionType,
        @CustomType.Parameter("tlsCipherPolicy") String tlsCipherPolicy,
        @CustomType.Parameter("unhealthyThreshold") Integer unhealthyThreshold,
        @CustomType.Parameter("xForwardedFor") String xForwardedFor,
        @CustomType.Parameter("xForwardedForSlbId") String xForwardedForSlbId,
        @CustomType.Parameter("xForwardedForSlbIp") String xForwardedForSlbIp,
        @CustomType.Parameter("xForwardedForSlbProto") String xForwardedForSlbProto) {
        this.backendPort = backendPort;
        this.bandwidth = bandwidth;
        this.caCertificateId = caCertificateId;
        this.cookie = cookie;
        this.cookieTimeout = cookieTimeout;
        this.description = description;
        this.enableHttp2 = enableHttp2;
        this.establishedTimeout = establishedTimeout;
        this.frontendPort = frontendPort;
        this.gzip = gzip;
        this.healthCheck = healthCheck;
        this.healthCheckConnectPort = healthCheckConnectPort;
        this.healthCheckConnectTimeout = healthCheckConnectTimeout;
        this.healthCheckDomain = healthCheckDomain;
        this.healthCheckHttpCode = healthCheckHttpCode;
        this.healthCheckInterval = healthCheckInterval;
        this.healthCheckTimeout = healthCheckTimeout;
        this.healthCheckType = healthCheckType;
        this.healthCheckUri = healthCheckUri;
        this.healthyThreshold = healthyThreshold;
        this.idleTimeout = idleTimeout;
        this.masterSlaveServerGroupId = masterSlaveServerGroupId;
        this.persistenceTimeout = persistenceTimeout;
        this.protocol = protocol;
        this.requestTimeout = requestTimeout;
        this.scheduler = scheduler;
        this.securityStatus = securityStatus;
        this.serverCertificateId = serverCertificateId;
        this.serverGroupId = serverGroupId;
        this.sslCertificateId = sslCertificateId;
        this.status = status;
        this.stickySession = stickySession;
        this.stickySessionType = stickySessionType;
        this.tlsCipherPolicy = tlsCipherPolicy;
        this.unhealthyThreshold = unhealthyThreshold;
        this.xForwardedFor = xForwardedFor;
        this.xForwardedForSlbId = xForwardedForSlbId;
        this.xForwardedForSlbIp = xForwardedForSlbIp;
        this.xForwardedForSlbProto = xForwardedForSlbProto;
    }

    /**
     * @return Port opened on the backend server to receive requests.
     * 
     */
    public Integer backendPort() {
        return this.backendPort;
    }
    /**
     * @return Peak bandwidth. If the value is set to -1, the listener is not limited by bandwidth.
     * 
     */
    public Integer bandwidth() {
        return this.bandwidth;
    }
    /**
     * @return ID of the CA certificate (only required when two-way authentication is used). Only available when the protocol is `https`.
     * 
     */
    public String caCertificateId() {
        return this.caCertificateId;
    }
    /**
     * @return Cookie configured by the backend server. Only available when the sticky_session_type is `server`.
     * 
     */
    public String cookie() {
        return this.cookie;
    }
    /**
     * @return Cookie timeout in seconds. Only available when the sticky_session_type is `insert`.
     * 
     */
    public Integer cookieTimeout() {
        return this.cookieTimeout;
    }
    /**
     * @return The description of slb listener.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return Whether to enable https listener support http2 or not. Valid values are `on` and `off`. Default to `on`.
     * 
     */
    public String enableHttp2() {
        return this.enableHttp2;
    }
    /**
     * @return Connection timeout in seconds for the Layer 4 TCP listener. Only available when the protocol is `tcp`.
     * 
     */
    public Integer establishedTimeout() {
        return this.establishedTimeout;
    }
    /**
     * @return Filter listeners by the specified frontend port.
     * 
     */
    public Integer frontendPort() {
        return this.frontendPort;
    }
    /**
     * @return Indicate whether Gzip compression is enabled or not. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    public String gzip() {
        return this.gzip;
    }
    /**
     * @return Indicate whether health check is enabled of not. Possible values are `on` and `off`.
     * 
     */
    public String healthCheck() {
        return this.healthCheck;
    }
    /**
     * @return Port used for health check.
     * 
     */
    public Integer healthCheckConnectPort() {
        return this.healthCheckConnectPort;
    }
    /**
     * @return Amount of time in seconds to wait for the response for a health check.
     * 
     */
    public Integer healthCheckConnectTimeout() {
        return this.healthCheckConnectTimeout;
    }
    /**
     * @return Domain name used for health check. The SLB sends HTTP head requests to the backend server, the domain is useful when the backend server verifies the host field in the requests. Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
     * 
     */
    public String healthCheckDomain() {
        return this.healthCheckDomain;
    }
    /**
     * @return HTTP status codes indicating that the health check is normal. It can contain several comma-separated values such as &#34;http_2xx,http_3xx&#34;. Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
     * 
     */
    public String healthCheckHttpCode() {
        return this.healthCheckHttpCode;
    }
    /**
     * @return Time interval between two consecutive health checks.
     * 
     */
    public Integer healthCheckInterval() {
        return this.healthCheckInterval;
    }
    /**
     * @return Amount of time in seconds to wait for the response from a health check. If an ECS instance sends no response within the specified timeout period, the health check fails. Only available when the protocol is `http` or `https`.
     * 
     */
    public Integer healthCheckTimeout() {
        return this.healthCheckTimeout;
    }
    /**
     * @return Health check method. Possible values are `tcp` and `http`. Only available when the protocol is `tcp`.
     * 
     */
    public String healthCheckType() {
        return this.healthCheckType;
    }
    /**
     * @return URI used for health check. Only available when the protocol is `http`, `https` or `tcp` (in this case health_check_type must be `http`).
     * 
     */
    public String healthCheckUri() {
        return this.healthCheckUri;
    }
    /**
     * @return Number of consecutive successes of health check performed on the same ECS instance (from failure to success).
     * 
     */
    public Integer healthyThreshold() {
        return this.healthyThreshold;
    }
    /**
     * @return Timeout of http or https listener established connection idle timeout. Valid value range: [1-60] in seconds. Default to 15.
     * 
     */
    public Integer idleTimeout() {
        return this.idleTimeout;
    }
    /**
     * @return ID of the active/standby server group.
     * 
     */
    public String masterSlaveServerGroupId() {
        return this.masterSlaveServerGroupId;
    }
    /**
     * @return Timeout value of the TCP connection in seconds. If the value is 0, the session persistence function is disabled. Only available when the protocol is `tcp`.
     * 
     */
    public Integer persistenceTimeout() {
        return this.persistenceTimeout;
    }
    /**
     * @return Filter listeners by the specified protocol. Valid values: `http`, `https`, `tcp` and `udp`.
     * 
     */
    public String protocol() {
        return this.protocol;
    }
    /**
     * @return Timeout of http or https listener request (which does not get response from backend) timeout. Valid value range: [1-180] in seconds. Default to 60.
     * 
     */
    public Integer requestTimeout() {
        return this.requestTimeout;
    }
    /**
     * @return Algorithm used to distribute traffic. Possible values: `wrr` (weighted round robin), `wlc` (weighted least connection) and `rr` (round robin).
     * 
     */
    public String scheduler() {
        return this.scheduler;
    }
    /**
     * @return Security status. Only available when the protocol is `https`.
     * 
     */
    public String securityStatus() {
        return this.securityStatus;
    }
    public String serverCertificateId() {
        return this.serverCertificateId;
    }
    /**
     * @return ID of the linked VServer group.
     * 
     */
    public String serverGroupId() {
        return this.serverGroupId;
    }
    /**
     * @return ID of the server certificate. Only available when the protocol is `https`.
     * 
     */
    public String sslCertificateId() {
        return this.sslCertificateId;
    }
    /**
     * @return Listener status.
     * 
     */
    public String status() {
        return this.status;
    }
    /**
     * @return Indicate whether session persistence is enabled or not. If enabled, all session requests from the same client are sent to the same backend server. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    public String stickySession() {
        return this.stickySession;
    }
    /**
     * @return Method used to handle the cookie. Possible values are `insert` (cookie added to the response) and `server` (cookie set by the backend server). Only available when the protocol is `http` or `https` and sticky_session is `on`.
     * 
     */
    public String stickySessionType() {
        return this.stickySessionType;
    }
    /**
     * @return Https listener TLS cipher policy. Valid values are `tls_cipher_policy_1_0`, `tls_cipher_policy_1_1`, `tls_cipher_policy_1_2`, `tls_cipher_policy_1_2_strict`. Default to `tls_cipher_policy_1_0`.
     * 
     */
    public String tlsCipherPolicy() {
        return this.tlsCipherPolicy;
    }
    /**
     * @return Number of consecutive failures of health check performed on the same ECS instance (from success to failure).
     * 
     */
    public Integer unhealthyThreshold() {
        return this.unhealthyThreshold;
    }
    /**
     * @return Indicate whether the HTTP header field &#34;X-Forwarded-For&#34; is added or not; it allows the backend server to know about the user&#39;s IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    public String xForwardedFor() {
        return this.xForwardedFor;
    }
    /**
     * @return Indicate whether the HTTP header field &#34;X-Forwarded-For_SLBID&#34; is added or not; it allows the backend server to know about the SLB ID. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    public String xForwardedForSlbId() {
        return this.xForwardedForSlbId;
    }
    /**
     * @return Indicate whether the HTTP header field &#34;X-Forwarded-For_SLBIP&#34; is added or not; it allows the backend server to know about the SLB IP address. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    public String xForwardedForSlbIp() {
        return this.xForwardedForSlbIp;
    }
    /**
     * @return Indicate whether the HTTP header field &#34;X-Forwarded-For_proto&#34; is added or not; it allows the backend server to know about the user&#39;s protocol. Possible values are `on` and `off`. Only available when the protocol is `http` or `https`.
     * 
     */
    public String xForwardedForSlbProto() {
        return this.xForwardedForSlbProto;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetListenersSlbListener defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private Integer backendPort;
        private Integer bandwidth;
        private String caCertificateId;
        private String cookie;
        private Integer cookieTimeout;
        private String description;
        private String enableHttp2;
        private Integer establishedTimeout;
        private Integer frontendPort;
        private String gzip;
        private String healthCheck;
        private Integer healthCheckConnectPort;
        private Integer healthCheckConnectTimeout;
        private String healthCheckDomain;
        private String healthCheckHttpCode;
        private Integer healthCheckInterval;
        private Integer healthCheckTimeout;
        private String healthCheckType;
        private String healthCheckUri;
        private Integer healthyThreshold;
        private Integer idleTimeout;
        private String masterSlaveServerGroupId;
        private Integer persistenceTimeout;
        private String protocol;
        private Integer requestTimeout;
        private String scheduler;
        private String securityStatus;
        private String serverCertificateId;
        private String serverGroupId;
        private String sslCertificateId;
        private String status;
        private String stickySession;
        private String stickySessionType;
        private String tlsCipherPolicy;
        private Integer unhealthyThreshold;
        private String xForwardedFor;
        private String xForwardedForSlbId;
        private String xForwardedForSlbIp;
        private String xForwardedForSlbProto;

        public Builder() {
    	      // Empty
        }

        public Builder(GetListenersSlbListener defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.backendPort = defaults.backendPort;
    	      this.bandwidth = defaults.bandwidth;
    	      this.caCertificateId = defaults.caCertificateId;
    	      this.cookie = defaults.cookie;
    	      this.cookieTimeout = defaults.cookieTimeout;
    	      this.description = defaults.description;
    	      this.enableHttp2 = defaults.enableHttp2;
    	      this.establishedTimeout = defaults.establishedTimeout;
    	      this.frontendPort = defaults.frontendPort;
    	      this.gzip = defaults.gzip;
    	      this.healthCheck = defaults.healthCheck;
    	      this.healthCheckConnectPort = defaults.healthCheckConnectPort;
    	      this.healthCheckConnectTimeout = defaults.healthCheckConnectTimeout;
    	      this.healthCheckDomain = defaults.healthCheckDomain;
    	      this.healthCheckHttpCode = defaults.healthCheckHttpCode;
    	      this.healthCheckInterval = defaults.healthCheckInterval;
    	      this.healthCheckTimeout = defaults.healthCheckTimeout;
    	      this.healthCheckType = defaults.healthCheckType;
    	      this.healthCheckUri = defaults.healthCheckUri;
    	      this.healthyThreshold = defaults.healthyThreshold;
    	      this.idleTimeout = defaults.idleTimeout;
    	      this.masterSlaveServerGroupId = defaults.masterSlaveServerGroupId;
    	      this.persistenceTimeout = defaults.persistenceTimeout;
    	      this.protocol = defaults.protocol;
    	      this.requestTimeout = defaults.requestTimeout;
    	      this.scheduler = defaults.scheduler;
    	      this.securityStatus = defaults.securityStatus;
    	      this.serverCertificateId = defaults.serverCertificateId;
    	      this.serverGroupId = defaults.serverGroupId;
    	      this.sslCertificateId = defaults.sslCertificateId;
    	      this.status = defaults.status;
    	      this.stickySession = defaults.stickySession;
    	      this.stickySessionType = defaults.stickySessionType;
    	      this.tlsCipherPolicy = defaults.tlsCipherPolicy;
    	      this.unhealthyThreshold = defaults.unhealthyThreshold;
    	      this.xForwardedFor = defaults.xForwardedFor;
    	      this.xForwardedForSlbId = defaults.xForwardedForSlbId;
    	      this.xForwardedForSlbIp = defaults.xForwardedForSlbIp;
    	      this.xForwardedForSlbProto = defaults.xForwardedForSlbProto;
        }

        public Builder backendPort(Integer backendPort) {
            this.backendPort = Objects.requireNonNull(backendPort);
            return this;
        }
        public Builder bandwidth(Integer bandwidth) {
            this.bandwidth = Objects.requireNonNull(bandwidth);
            return this;
        }
        public Builder caCertificateId(String caCertificateId) {
            this.caCertificateId = Objects.requireNonNull(caCertificateId);
            return this;
        }
        public Builder cookie(String cookie) {
            this.cookie = Objects.requireNonNull(cookie);
            return this;
        }
        public Builder cookieTimeout(Integer cookieTimeout) {
            this.cookieTimeout = Objects.requireNonNull(cookieTimeout);
            return this;
        }
        public Builder description(String description) {
            this.description = Objects.requireNonNull(description);
            return this;
        }
        public Builder enableHttp2(String enableHttp2) {
            this.enableHttp2 = Objects.requireNonNull(enableHttp2);
            return this;
        }
        public Builder establishedTimeout(Integer establishedTimeout) {
            this.establishedTimeout = Objects.requireNonNull(establishedTimeout);
            return this;
        }
        public Builder frontendPort(Integer frontendPort) {
            this.frontendPort = Objects.requireNonNull(frontendPort);
            return this;
        }
        public Builder gzip(String gzip) {
            this.gzip = Objects.requireNonNull(gzip);
            return this;
        }
        public Builder healthCheck(String healthCheck) {
            this.healthCheck = Objects.requireNonNull(healthCheck);
            return this;
        }
        public Builder healthCheckConnectPort(Integer healthCheckConnectPort) {
            this.healthCheckConnectPort = Objects.requireNonNull(healthCheckConnectPort);
            return this;
        }
        public Builder healthCheckConnectTimeout(Integer healthCheckConnectTimeout) {
            this.healthCheckConnectTimeout = Objects.requireNonNull(healthCheckConnectTimeout);
            return this;
        }
        public Builder healthCheckDomain(String healthCheckDomain) {
            this.healthCheckDomain = Objects.requireNonNull(healthCheckDomain);
            return this;
        }
        public Builder healthCheckHttpCode(String healthCheckHttpCode) {
            this.healthCheckHttpCode = Objects.requireNonNull(healthCheckHttpCode);
            return this;
        }
        public Builder healthCheckInterval(Integer healthCheckInterval) {
            this.healthCheckInterval = Objects.requireNonNull(healthCheckInterval);
            return this;
        }
        public Builder healthCheckTimeout(Integer healthCheckTimeout) {
            this.healthCheckTimeout = Objects.requireNonNull(healthCheckTimeout);
            return this;
        }
        public Builder healthCheckType(String healthCheckType) {
            this.healthCheckType = Objects.requireNonNull(healthCheckType);
            return this;
        }
        public Builder healthCheckUri(String healthCheckUri) {
            this.healthCheckUri = Objects.requireNonNull(healthCheckUri);
            return this;
        }
        public Builder healthyThreshold(Integer healthyThreshold) {
            this.healthyThreshold = Objects.requireNonNull(healthyThreshold);
            return this;
        }
        public Builder idleTimeout(Integer idleTimeout) {
            this.idleTimeout = Objects.requireNonNull(idleTimeout);
            return this;
        }
        public Builder masterSlaveServerGroupId(String masterSlaveServerGroupId) {
            this.masterSlaveServerGroupId = Objects.requireNonNull(masterSlaveServerGroupId);
            return this;
        }
        public Builder persistenceTimeout(Integer persistenceTimeout) {
            this.persistenceTimeout = Objects.requireNonNull(persistenceTimeout);
            return this;
        }
        public Builder protocol(String protocol) {
            this.protocol = Objects.requireNonNull(protocol);
            return this;
        }
        public Builder requestTimeout(Integer requestTimeout) {
            this.requestTimeout = Objects.requireNonNull(requestTimeout);
            return this;
        }
        public Builder scheduler(String scheduler) {
            this.scheduler = Objects.requireNonNull(scheduler);
            return this;
        }
        public Builder securityStatus(String securityStatus) {
            this.securityStatus = Objects.requireNonNull(securityStatus);
            return this;
        }
        public Builder serverCertificateId(String serverCertificateId) {
            this.serverCertificateId = Objects.requireNonNull(serverCertificateId);
            return this;
        }
        public Builder serverGroupId(String serverGroupId) {
            this.serverGroupId = Objects.requireNonNull(serverGroupId);
            return this;
        }
        public Builder sslCertificateId(String sslCertificateId) {
            this.sslCertificateId = Objects.requireNonNull(sslCertificateId);
            return this;
        }
        public Builder status(String status) {
            this.status = Objects.requireNonNull(status);
            return this;
        }
        public Builder stickySession(String stickySession) {
            this.stickySession = Objects.requireNonNull(stickySession);
            return this;
        }
        public Builder stickySessionType(String stickySessionType) {
            this.stickySessionType = Objects.requireNonNull(stickySessionType);
            return this;
        }
        public Builder tlsCipherPolicy(String tlsCipherPolicy) {
            this.tlsCipherPolicy = Objects.requireNonNull(tlsCipherPolicy);
            return this;
        }
        public Builder unhealthyThreshold(Integer unhealthyThreshold) {
            this.unhealthyThreshold = Objects.requireNonNull(unhealthyThreshold);
            return this;
        }
        public Builder xForwardedFor(String xForwardedFor) {
            this.xForwardedFor = Objects.requireNonNull(xForwardedFor);
            return this;
        }
        public Builder xForwardedForSlbId(String xForwardedForSlbId) {
            this.xForwardedForSlbId = Objects.requireNonNull(xForwardedForSlbId);
            return this;
        }
        public Builder xForwardedForSlbIp(String xForwardedForSlbIp) {
            this.xForwardedForSlbIp = Objects.requireNonNull(xForwardedForSlbIp);
            return this;
        }
        public Builder xForwardedForSlbProto(String xForwardedForSlbProto) {
            this.xForwardedForSlbProto = Objects.requireNonNull(xForwardedForSlbProto);
            return this;
        }        public GetListenersSlbListener build() {
            return new GetListenersSlbListener(backendPort, bandwidth, caCertificateId, cookie, cookieTimeout, description, enableHttp2, establishedTimeout, frontendPort, gzip, healthCheck, healthCheckConnectPort, healthCheckConnectTimeout, healthCheckDomain, healthCheckHttpCode, healthCheckInterval, healthCheckTimeout, healthCheckType, healthCheckUri, healthyThreshold, idleTimeout, masterSlaveServerGroupId, persistenceTimeout, protocol, requestTimeout, scheduler, securityStatus, serverCertificateId, serverGroupId, sslCertificateId, status, stickySession, stickySessionType, tlsCipherPolicy, unhealthyThreshold, xForwardedFor, xForwardedForSlbId, xForwardedForSlbIp, xForwardedForSlbProto);
        }
    }
}
