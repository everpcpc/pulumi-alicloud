# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'LoadBalancerAccessLogConfig',
    'LoadBalancerLoadBalancerBillingConfig',
    'LoadBalancerModificationProtectionConfig',
    'LoadBalancerZoneMapping',
    'ServerGroupHealthCheckConfig',
    'ServerGroupServer',
    'ServerGroupStickySessionConfig',
    'GetLoadBalancersBalancerResult',
    'GetLoadBalancersBalancerAccessLogConfigResult',
    'GetLoadBalancersBalancerDeletionProtectionConfigResult',
    'GetLoadBalancersBalancerLoadBalancerBillingConfigResult',
    'GetLoadBalancersBalancerLoadBalancerOperationLockResult',
    'GetLoadBalancersBalancerModificationProtectionConfigResult',
    'GetLoadBalancersBalancerZoneMappingResult',
    'GetLoadBalancersBalancerZoneMappingLoadBalancerAddressResult',
    'GetSecurityPoliciesPolicyResult',
    'GetServerGroupsGroupResult',
    'GetServerGroupsGroupHealthCheckConfigResult',
    'GetServerGroupsGroupServerResult',
    'GetServerGroupsGroupStickySessionConfigResult',
    'GetZonesZoneResult',
]

@pulumi.output_type
class LoadBalancerAccessLogConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logProject":
            suggest = "log_project"
        elif key == "logStore":
            suggest = "log_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerAccessLogConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerAccessLogConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerAccessLogConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_project: Optional[str] = None,
                 log_store: Optional[str] = None):
        """
        :param str log_project: The log service that access logs are shipped to.
        :param str log_store: The log service that access logs are shipped to.
        """
        if log_project is not None:
            pulumi.set(__self__, "log_project", log_project)
        if log_store is not None:
            pulumi.set(__self__, "log_store", log_store)

    @property
    @pulumi.getter(name="logProject")
    def log_project(self) -> Optional[str]:
        """
        The log service that access logs are shipped to.
        """
        return pulumi.get(self, "log_project")

    @property
    @pulumi.getter(name="logStore")
    def log_store(self) -> Optional[str]:
        """
        The log service that access logs are shipped to.
        """
        return pulumi.get(self, "log_store")


@pulumi.output_type
class LoadBalancerLoadBalancerBillingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "payType":
            suggest = "pay_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerLoadBalancerBillingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerLoadBalancerBillingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerLoadBalancerBillingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pay_type: str):
        """
        :param str pay_type: The billing method of the ALB instance. Valid value: `PayAsYouGo`.
        """
        pulumi.set(__self__, "pay_type", pay_type)

    @property
    @pulumi.getter(name="payType")
    def pay_type(self) -> str:
        """
        The billing method of the ALB instance. Valid value: `PayAsYouGo`.
        """
        return pulumi.get(self, "pay_type")


@pulumi.output_type
class LoadBalancerModificationProtectionConfig(dict):
    def __init__(__self__, *,
                 reason: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str reason: The reason for modification protection. This parameter must be 2 to 128 characters in length, and can contain letters, digits, periods, underscores, and hyphens. The reason must start with a letter. This parameter is required only if `ModificationProtectionStatus` is set to `ConsoleProtection`.
        :param str status: Specifies whether to enable the configuration read-only mode for the ALB instance. Valid values: `NonProtection` and `ConsoleProtection`.
        """
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for modification protection. This parameter must be 2 to 128 characters in length, and can contain letters, digits, periods, underscores, and hyphens. The reason must start with a letter. This parameter is required only if `ModificationProtectionStatus` is set to `ConsoleProtection`.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Specifies whether to enable the configuration read-only mode for the ALB instance. Valid values: `NonProtection` and `ConsoleProtection`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class LoadBalancerZoneMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vswitchId":
            suggest = "vswitch_id"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerZoneMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerZoneMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerZoneMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vswitch_id: str,
                 zone_id: str):
        """
        :param str vswitch_id: The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        :param str zone_id: The ID of the zone to which the ALB instance belongs.
        """
        pulumi.set(__self__, "vswitch_id", vswitch_id)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        """
        return pulumi.get(self, "vswitch_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The ID of the zone to which the ALB instance belongs.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class ServerGroupHealthCheckConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckCodes":
            suggest = "health_check_codes"
        elif key == "healthCheckConnectPort":
            suggest = "health_check_connect_port"
        elif key == "healthCheckEnabled":
            suggest = "health_check_enabled"
        elif key == "healthCheckHost":
            suggest = "health_check_host"
        elif key == "healthCheckHttpVersion":
            suggest = "health_check_http_version"
        elif key == "healthCheckInterval":
            suggest = "health_check_interval"
        elif key == "healthCheckMethod":
            suggest = "health_check_method"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "healthCheckProtocol":
            suggest = "health_check_protocol"
        elif key == "healthCheckTimeout":
            suggest = "health_check_timeout"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupHealthCheckConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupHealthCheckConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupHealthCheckConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check_codes: Optional[Sequence[str]] = None,
                 health_check_connect_port: Optional[int] = None,
                 health_check_enabled: Optional[bool] = None,
                 health_check_host: Optional[str] = None,
                 health_check_http_version: Optional[str] = None,
                 health_check_interval: Optional[int] = None,
                 health_check_method: Optional[str] = None,
                 health_check_path: Optional[str] = None,
                 health_check_protocol: Optional[str] = None,
                 health_check_timeout: Optional[int] = None,
                 healthy_threshold: Optional[int] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param Sequence[str] health_check_codes: The status code for a successful health check. Multiple status codes can be specified as a list. Valid values: `http_2xx`, `http_3xx`, `http_4xx`, and `http_5xx`. Default value: `http_2xx`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        :param int health_check_connect_port: The port of the backend server that is used for health checks. Valid values: `0` to `65535`. Default value: `0`. A value of 0 indicates that a backend server port is used for health checks.
        :param bool health_check_enabled: Indicates whether health checks are enabled. Valid values: `true`, `false`. Default value: `true`.
        :param str health_check_host: The domain name that is used for health checks.
        :param str health_check_http_version: HTTP protocol version. Valid values: `HTTP1.0` and `HTTP1.1`. Default value: `HTTP1.1`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        :param int health_check_interval: The time interval between two consecutive health checks. Unit: seconds. Valid values: `1` to `50`. Default value: `2`.
        :param str health_check_method: Health check method. Valid values: `GET` and `HEAD`. Default: `GET`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        :param str health_check_path: The forwarding rule path of health checks. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        :param str health_check_protocol: Health check protocol. Valid values: `HTTP` and `TCP`.
        :param int health_check_timeout: The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy. Unit: seconds. Valid values: 1 to 300. Default value: 5. **NOTE:** If the value of the `HealthCHeckTimeout` parameter is smaller than that of the `HealthCheckInterval` parameter, the value of the `HealthCHeckTimeout` parameter is ignored and the value of the `HealthCheckInterval` parameter is regarded as the timeout period.
        :param int healthy_threshold: The number of health checks that an unhealthy backend server must pass consecutively before it is declared healthy. In this case, the health check state is changed from fail to success. Valid values: 2 to 10. Default value: 3.
        :param int unhealthy_threshold: The number of consecutive health checks that a healthy backend server must consecutively fail before it is declared unhealthy. In this case, the health check state is changed from success to fail. Valid values: `2` to `10`. Default value: `3`.
        """
        if health_check_codes is not None:
            pulumi.set(__self__, "health_check_codes", health_check_codes)
        if health_check_connect_port is not None:
            pulumi.set(__self__, "health_check_connect_port", health_check_connect_port)
        if health_check_enabled is not None:
            pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if health_check_host is not None:
            pulumi.set(__self__, "health_check_host", health_check_host)
        if health_check_http_version is not None:
            pulumi.set(__self__, "health_check_http_version", health_check_http_version)
        if health_check_interval is not None:
            pulumi.set(__self__, "health_check_interval", health_check_interval)
        if health_check_method is not None:
            pulumi.set(__self__, "health_check_method", health_check_method)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if health_check_protocol is not None:
            pulumi.set(__self__, "health_check_protocol", health_check_protocol)
        if health_check_timeout is not None:
            pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="healthCheckCodes")
    def health_check_codes(self) -> Optional[Sequence[str]]:
        """
        The status code for a successful health check. Multiple status codes can be specified as a list. Valid values: `http_2xx`, `http_3xx`, `http_4xx`, and `http_5xx`. Default value: `http_2xx`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        """
        return pulumi.get(self, "health_check_codes")

    @property
    @pulumi.getter(name="healthCheckConnectPort")
    def health_check_connect_port(self) -> Optional[int]:
        """
        The port of the backend server that is used for health checks. Valid values: `0` to `65535`. Default value: `0`. A value of 0 indicates that a backend server port is used for health checks.
        """
        return pulumi.get(self, "health_check_connect_port")

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> Optional[bool]:
        """
        Indicates whether health checks are enabled. Valid values: `true`, `false`. Default value: `true`.
        """
        return pulumi.get(self, "health_check_enabled")

    @property
    @pulumi.getter(name="healthCheckHost")
    def health_check_host(self) -> Optional[str]:
        """
        The domain name that is used for health checks.
        """
        return pulumi.get(self, "health_check_host")

    @property
    @pulumi.getter(name="healthCheckHttpVersion")
    def health_check_http_version(self) -> Optional[str]:
        """
        HTTP protocol version. Valid values: `HTTP1.0` and `HTTP1.1`. Default value: `HTTP1.1`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        """
        return pulumi.get(self, "health_check_http_version")

    @property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> Optional[int]:
        """
        The time interval between two consecutive health checks. Unit: seconds. Valid values: `1` to `50`. Default value: `2`.
        """
        return pulumi.get(self, "health_check_interval")

    @property
    @pulumi.getter(name="healthCheckMethod")
    def health_check_method(self) -> Optional[str]:
        """
        Health check method. Valid values: `GET` and `HEAD`. Default: `GET`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        """
        return pulumi.get(self, "health_check_method")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        The forwarding rule path of health checks. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="healthCheckProtocol")
    def health_check_protocol(self) -> Optional[str]:
        """
        Health check protocol. Valid values: `HTTP` and `TCP`.
        """
        return pulumi.get(self, "health_check_protocol")

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> Optional[int]:
        """
        The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy. Unit: seconds. Valid values: 1 to 300. Default value: 5. **NOTE:** If the value of the `HealthCHeckTimeout` parameter is smaller than that of the `HealthCheckInterval` parameter, the value of the `HealthCHeckTimeout` parameter is ignored and the value of the `HealthCheckInterval` parameter is regarded as the timeout period.
        """
        return pulumi.get(self, "health_check_timeout")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        The number of health checks that an unhealthy backend server must pass consecutively before it is declared healthy. In this case, the health check state is changed from fail to success. Valid values: 2 to 10. Default value: 3.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        The number of consecutive health checks that a healthy backend server must consecutively fail before it is declared unhealthy. In this case, the health check state is changed from success to fail. Valid values: `2` to `10`. Default value: `3`.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class ServerGroupServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverId":
            suggest = "server_id"
        elif key == "serverIp":
            suggest = "server_ip"
        elif key == "serverType":
            suggest = "server_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 port: Optional[int] = None,
                 server_id: Optional[str] = None,
                 server_ip: Optional[str] = None,
                 server_type: Optional[str] = None,
                 status: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str description: The description of the server.
        :param int port: The port that is used by the server. Valid values: `1` to `65535`.
        :param str server_id: The ID of the ECS instance, ENI instance or ECI instance.
        :param str server_ip: The IP address of the ENI instance when it is in the inclusive ENI mode.
        :param str server_type: The type of the server. The type of the server. Valid values: `Ecs`, `Eni` and `Eci`.
        :param str status: The status of the resource.
        :param int weight: The weight of the server.  Valid values: `0` to `100`. Default value: `100`. If the value is set to `0`, no requests are forwarded to the server.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server_id is not None:
            pulumi.set(__self__, "server_id", server_id)
        if server_ip is not None:
            pulumi.set(__self__, "server_ip", server_ip)
        if server_type is not None:
            pulumi.set(__self__, "server_type", server_type)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the server.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port that is used by the server. Valid values: `1` to `65535`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> Optional[str]:
        """
        The ID of the ECS instance, ENI instance or ECI instance.
        """
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter(name="serverIp")
    def server_ip(self) -> Optional[str]:
        """
        The IP address of the ENI instance when it is in the inclusive ENI mode.
        """
        return pulumi.get(self, "server_ip")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[str]:
        """
        The type of the server. The type of the server. Valid values: `Ecs`, `Eni` and `Eci`.
        """
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the resource.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The weight of the server.  Valid values: `0` to `100`. Default value: `100`. If the value is set to `0`, no requests are forwarded to the server.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class ServerGroupStickySessionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieTimeout":
            suggest = "cookie_timeout"
        elif key == "stickySessionEnabled":
            suggest = "sticky_session_enabled"
        elif key == "stickySessionType":
            suggest = "sticky_session_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupStickySessionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupStickySessionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupStickySessionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional[str] = None,
                 cookie_timeout: Optional[int] = None,
                 sticky_session_enabled: Optional[bool] = None,
                 sticky_session_type: Optional[str] = None):
        """
        :param str cookie: the cookie that is configured on the server. **NOTE:** This parameter exists if the `StickySession` parameter is set to `On` and the `StickySessionType` parameter is set to `server`.
        :param int cookie_timeout: The timeout period of a cookie. The timeout period of a cookie. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
        :param bool sticky_session_enabled: Indicates whether sticky session is enabled. Values: `true` and `false`. Default value: `false`.  **NOTE:** This parameter exists if the `StickySession` parameter is set to `On`.
        :param str sticky_session_type: The method that is used to handle a cookie. Values: `Server` and `Insert`.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if cookie_timeout is not None:
            pulumi.set(__self__, "cookie_timeout", cookie_timeout)
        if sticky_session_enabled is not None:
            pulumi.set(__self__, "sticky_session_enabled", sticky_session_enabled)
        if sticky_session_type is not None:
            pulumi.set(__self__, "sticky_session_type", sticky_session_type)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[str]:
        """
        the cookie that is configured on the server. **NOTE:** This parameter exists if the `StickySession` parameter is set to `On` and the `StickySessionType` parameter is set to `server`.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="cookieTimeout")
    def cookie_timeout(self) -> Optional[int]:
        """
        The timeout period of a cookie. The timeout period of a cookie. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
        """
        return pulumi.get(self, "cookie_timeout")

    @property
    @pulumi.getter(name="stickySessionEnabled")
    def sticky_session_enabled(self) -> Optional[bool]:
        """
        Indicates whether sticky session is enabled. Values: `true` and `false`. Default value: `false`.  **NOTE:** This parameter exists if the `StickySession` parameter is set to `On`.
        """
        return pulumi.get(self, "sticky_session_enabled")

    @property
    @pulumi.getter(name="stickySessionType")
    def sticky_session_type(self) -> Optional[str]:
        """
        The method that is used to handle a cookie. Values: `Server` and `Insert`.
        """
        return pulumi.get(self, "sticky_session_type")


@pulumi.output_type
class GetLoadBalancersBalancerResult(dict):
    def __init__(__self__, *,
                 access_log_configs: Sequence['outputs.GetLoadBalancersBalancerAccessLogConfigResult'],
                 address_allocated_mode: str,
                 address_type: str,
                 bandwidth_package_id: str,
                 create_time: str,
                 deletion_protection_configs: Sequence['outputs.GetLoadBalancersBalancerDeletionProtectionConfigResult'],
                 dns_name: str,
                 id: str,
                 load_balancer_billing_configs: Sequence['outputs.GetLoadBalancersBalancerLoadBalancerBillingConfigResult'],
                 load_balancer_bussiness_status: str,
                 load_balancer_edition: str,
                 load_balancer_id: str,
                 load_balancer_name: str,
                 load_balancer_operation_locks: Sequence['outputs.GetLoadBalancersBalancerLoadBalancerOperationLockResult'],
                 modification_protection_configs: Sequence['outputs.GetLoadBalancersBalancerModificationProtectionConfigResult'],
                 resource_group_id: str,
                 status: str,
                 tags: Mapping[str, Any],
                 vpc_id: str,
                 zone_mappings: Sequence['outputs.GetLoadBalancersBalancerZoneMappingResult']):
        """
        :param Sequence['GetLoadBalancersBalancerAccessLogConfigArgs'] access_log_configs: The Access Logging Configuration Structure.
        :param str address_allocated_mode: The method in which IP addresses are assigned. Valid values:  Fixed: The ALB instance
               uses a fixed IP address. Dynamic (default): An IP address is dynamically assigned to each zone of the ALB
               instance.
        :param str address_type: The type of IP address that the ALB instance uses to provide services.
        :param str bandwidth_package_id: The ID of the EIP bandwidth plan which is associated with an ALB instance that uses a
               public IP address.
        :param str create_time: The creation time of the resource.
        :param Sequence['GetLoadBalancersBalancerDeletionProtectionConfigArgs'] deletion_protection_configs: Remove the Protection Configuration.
        :param str dns_name: DNS Domain Name.
        :param str id: The ID of the Load Balancer.
        :param Sequence['GetLoadBalancersBalancerLoadBalancerBillingConfigArgs'] load_balancer_billing_configs: The configuration of the billing method.
        :param str load_balancer_bussiness_status: Load Balancing of the Service Status. Valid Values: `Abnormal` and `Normal`.
        :param str load_balancer_edition: The edition of the ALB instance.
        :param str load_balancer_id: The first ID of the resource.
        :param str load_balancer_name: The name of the resource.
        :param Sequence['GetLoadBalancersBalancerLoadBalancerOperationLockArgs'] load_balancer_operation_locks: The Load Balancing Operations Lock Configuration.
        :param Sequence['GetLoadBalancersBalancerModificationProtectionConfigArgs'] modification_protection_configs: Modify the Protection Configuration.
        :param str resource_group_id: The ID of the resource group.
        :param str status: The The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
        :param Mapping[str, Any] tags: The tag of the resource.
        :param str vpc_id: The ID of the virtual private cloud (VPC) where the ALB instance is deployed.
        :param Sequence['GetLoadBalancersBalancerZoneMappingArgs'] zone_mappings: The zones and vSwitches. You must specify at least two zones.
        """
        pulumi.set(__self__, "access_log_configs", access_log_configs)
        pulumi.set(__self__, "address_allocated_mode", address_allocated_mode)
        pulumi.set(__self__, "address_type", address_type)
        pulumi.set(__self__, "bandwidth_package_id", bandwidth_package_id)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "deletion_protection_configs", deletion_protection_configs)
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "load_balancer_billing_configs", load_balancer_billing_configs)
        pulumi.set(__self__, "load_balancer_bussiness_status", load_balancer_bussiness_status)
        pulumi.set(__self__, "load_balancer_edition", load_balancer_edition)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        pulumi.set(__self__, "load_balancer_operation_locks", load_balancer_operation_locks)
        pulumi.set(__self__, "modification_protection_configs", modification_protection_configs)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "zone_mappings", zone_mappings)

    @property
    @pulumi.getter(name="accessLogConfigs")
    def access_log_configs(self) -> Sequence['outputs.GetLoadBalancersBalancerAccessLogConfigResult']:
        """
        The Access Logging Configuration Structure.
        """
        return pulumi.get(self, "access_log_configs")

    @property
    @pulumi.getter(name="addressAllocatedMode")
    def address_allocated_mode(self) -> str:
        """
        The method in which IP addresses are assigned. Valid values:  Fixed: The ALB instance
        uses a fixed IP address. Dynamic (default): An IP address is dynamically assigned to each zone of the ALB
        instance.
        """
        return pulumi.get(self, "address_allocated_mode")

    @property
    @pulumi.getter(name="addressType")
    def address_type(self) -> str:
        """
        The type of IP address that the ALB instance uses to provide services.
        """
        return pulumi.get(self, "address_type")

    @property
    @pulumi.getter(name="bandwidthPackageId")
    def bandwidth_package_id(self) -> str:
        """
        The ID of the EIP bandwidth plan which is associated with an ALB instance that uses a
        public IP address.
        """
        return pulumi.get(self, "bandwidth_package_id")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The creation time of the resource.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="deletionProtectionConfigs")
    def deletion_protection_configs(self) -> Sequence['outputs.GetLoadBalancersBalancerDeletionProtectionConfigResult']:
        """
        Remove the Protection Configuration.
        """
        return pulumi.get(self, "deletion_protection_configs")

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> str:
        """
        DNS Domain Name.
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="loadBalancerBillingConfigs")
    def load_balancer_billing_configs(self) -> Sequence['outputs.GetLoadBalancersBalancerLoadBalancerBillingConfigResult']:
        """
        The configuration of the billing method.
        """
        return pulumi.get(self, "load_balancer_billing_configs")

    @property
    @pulumi.getter(name="loadBalancerBussinessStatus")
    def load_balancer_bussiness_status(self) -> str:
        """
        Load Balancing of the Service Status. Valid Values: `Abnormal` and `Normal`.
        """
        return pulumi.get(self, "load_balancer_bussiness_status")

    @property
    @pulumi.getter(name="loadBalancerEdition")
    def load_balancer_edition(self) -> str:
        """
        The edition of the ALB instance.
        """
        return pulumi.get(self, "load_balancer_edition")

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "load_balancer_id")

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter(name="loadBalancerOperationLocks")
    def load_balancer_operation_locks(self) -> Sequence['outputs.GetLoadBalancersBalancerLoadBalancerOperationLockResult']:
        """
        The Load Balancing Operations Lock Configuration.
        """
        return pulumi.get(self, "load_balancer_operation_locks")

    @property
    @pulumi.getter(name="modificationProtectionConfigs")
    def modification_protection_configs(self) -> Sequence['outputs.GetLoadBalancersBalancerModificationProtectionConfigResult']:
        """
        Modify the Protection Configuration.
        """
        return pulumi.get(self, "modification_protection_configs")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, Any]:
        """
        The tag of the resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The ID of the virtual private cloud (VPC) where the ALB instance is deployed.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="zoneMappings")
    def zone_mappings(self) -> Sequence['outputs.GetLoadBalancersBalancerZoneMappingResult']:
        """
        The zones and vSwitches. You must specify at least two zones.
        """
        return pulumi.get(self, "zone_mappings")


@pulumi.output_type
class GetLoadBalancersBalancerAccessLogConfigResult(dict):
    def __init__(__self__, *,
                 log_project: str,
                 log_store: str):
        """
        :param str log_project: The log service that access logs are shipped to.
        :param str log_store: The logstore that access logs are shipped to.
        """
        pulumi.set(__self__, "log_project", log_project)
        pulumi.set(__self__, "log_store", log_store)

    @property
    @pulumi.getter(name="logProject")
    def log_project(self) -> str:
        """
        The log service that access logs are shipped to.
        """
        return pulumi.get(self, "log_project")

    @property
    @pulumi.getter(name="logStore")
    def log_store(self) -> str:
        """
        The logstore that access logs are shipped to.
        """
        return pulumi.get(self, "log_store")


@pulumi.output_type
class GetLoadBalancersBalancerDeletionProtectionConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 enabled_time: str):
        """
        :param bool enabled: Remove the Protection Status.
        :param str enabled_time: Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm:SSZ.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "enabled_time", enabled_time)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Remove the Protection Status.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="enabledTime")
    def enabled_time(self) -> str:
        """
        Deletion Protection Turn-on Time Use Greenwich Mean Time, in the Format of Yyyy-MM-ddTHH: mm:SSZ.
        """
        return pulumi.get(self, "enabled_time")


@pulumi.output_type
class GetLoadBalancersBalancerLoadBalancerBillingConfigResult(dict):
    def __init__(__self__, *,
                 pay_type: str):
        """
        :param str pay_type: The billing method of the ALB instance. Valid value: `PayAsYouGo`.
        """
        pulumi.set(__self__, "pay_type", pay_type)

    @property
    @pulumi.getter(name="payType")
    def pay_type(self) -> str:
        """
        The billing method of the ALB instance. Valid value: `PayAsYouGo`.
        """
        return pulumi.get(self, "pay_type")


@pulumi.output_type
class GetLoadBalancersBalancerLoadBalancerOperationLockResult(dict):
    def __init__(__self__, *,
                 lock_reason: str,
                 lock_type: str):
        """
        :param str lock_reason: The Locking of the Reasons. In 'loadbalancerbussinessstatus' **Exception When Effective,.
        :param str lock_type: The Locking of the Type. Valid Values: `securitylocked`,`relatedresourcelocked`, `financiallocked`, and `residuallocked`.
        """
        pulumi.set(__self__, "lock_reason", lock_reason)
        pulumi.set(__self__, "lock_type", lock_type)

    @property
    @pulumi.getter(name="lockReason")
    def lock_reason(self) -> str:
        """
        The Locking of the Reasons. In 'loadbalancerbussinessstatus' **Exception When Effective,.
        """
        return pulumi.get(self, "lock_reason")

    @property
    @pulumi.getter(name="lockType")
    def lock_type(self) -> str:
        """
        The Locking of the Type. Valid Values: `securitylocked`,`relatedresourcelocked`, `financiallocked`, and `residuallocked`.
        """
        return pulumi.get(self, "lock_type")


@pulumi.output_type
class GetLoadBalancersBalancerModificationProtectionConfigResult(dict):
    def __init__(__self__, *,
                 reason: str,
                 status: str):
        """
        :param str reason: The reason for modification protection. This parameter must be 2 to 128 characters in length, and can contain letters, digits, periods, underscores, and hyphens. The reason must start with a letter. This parameter is required only if `ModificationProtectionStatus` is set to `ConsoleProtection`.
        :param str status: The The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
        """
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def reason(self) -> str:
        """
        The reason for modification protection. This parameter must be 2 to 128 characters in length, and can contain letters, digits, periods, underscores, and hyphens. The reason must start with a letter. This parameter is required only if `ModificationProtectionStatus` is set to `ConsoleProtection`.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The The load balancer status. Valid values: `Active`, `Configuring`, `CreateFailed`, `Inactive` and `Provisioning`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetLoadBalancersBalancerZoneMappingResult(dict):
    def __init__(__self__, *,
                 load_balancer_addresses: Sequence['outputs.GetLoadBalancersBalancerZoneMappingLoadBalancerAddressResult'],
                 vswitch_id: str,
                 zone_id: str):
        """
        :param str vswitch_id: The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        :param str zone_id: The ID of the zone to which the ALB instance belongs.
        """
        pulumi.set(__self__, "load_balancer_addresses", load_balancer_addresses)
        pulumi.set(__self__, "vswitch_id", vswitch_id)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="loadBalancerAddresses")
    def load_balancer_addresses(self) -> Sequence['outputs.GetLoadBalancersBalancerZoneMappingLoadBalancerAddressResult']:
        return pulumi.get(self, "load_balancer_addresses")

    @property
    @pulumi.getter(name="vswitchId")
    def vswitch_id(self) -> str:
        """
        The ID of the vSwitch that corresponds to the zone. Each zone can use only one vSwitch and subnet.
        """
        return pulumi.get(self, "vswitch_id")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The ID of the zone to which the ALB instance belongs.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetLoadBalancersBalancerZoneMappingLoadBalancerAddressResult(dict):
    def __init__(__self__, *,
                 address: str):
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")


@pulumi.output_type
class GetSecurityPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 ciphers: Sequence[str],
                 id: str,
                 resource_group_id: str,
                 security_policy_id: str,
                 security_policy_name: str,
                 status: str,
                 tls_versions: Sequence[str]):
        """
        :param Sequence[str] ciphers: The supported cipher suites, which are determined by the TLS protocol version.
        :param str id: The ID of the Security Policy.
        :param str resource_group_id: The ID of the resource group.
        :param str security_policy_id: The first ID of the resource.
        :param str security_policy_name: The name of the resource. The name must be 2 to 128 characters in length and must start with a letter. It can contain digits, periods (.), underscores (_), and hyphens (-).
        :param str status: The status of the resource.
        :param Sequence[str] tls_versions: The TLS protocol versions that are supported. Valid values: TLSv1.0, TLSv1.1, TLSv1.2 and TLSv1.3.
        """
        pulumi.set(__self__, "ciphers", ciphers)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "resource_group_id", resource_group_id)
        pulumi.set(__self__, "security_policy_id", security_policy_id)
        pulumi.set(__self__, "security_policy_name", security_policy_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tls_versions", tls_versions)

    @property
    @pulumi.getter
    def ciphers(self) -> Sequence[str]:
        """
        The supported cipher suites, which are determined by the TLS protocol version.
        """
        return pulumi.get(self, "ciphers")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Security Policy.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> str:
        """
        The ID of the resource group.
        """
        return pulumi.get(self, "resource_group_id")

    @property
    @pulumi.getter(name="securityPolicyId")
    def security_policy_id(self) -> str:
        """
        The first ID of the resource.
        """
        return pulumi.get(self, "security_policy_id")

    @property
    @pulumi.getter(name="securityPolicyName")
    def security_policy_name(self) -> str:
        """
        The name of the resource. The name must be 2 to 128 characters in length and must start with a letter. It can contain digits, periods (.), underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "security_policy_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the resource.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tlsVersions")
    def tls_versions(self) -> Sequence[str]:
        """
        The TLS protocol versions that are supported. Valid values: TLSv1.0, TLSv1.1, TLSv1.2 and TLSv1.3.
        """
        return pulumi.get(self, "tls_versions")


@pulumi.output_type
class GetServerGroupsGroupResult(dict):
    def __init__(__self__, *,
                 health_check_configs: Sequence['outputs.GetServerGroupsGroupHealthCheckConfigResult'],
                 id: str,
                 protocol: str,
                 scheduler: str,
                 server_group_id: str,
                 server_group_name: str,
                 servers: Sequence['outputs.GetServerGroupsGroupServerResult'],
                 status: str,
                 sticky_session_configs: Sequence['outputs.GetServerGroupsGroupStickySessionConfigResult'],
                 vpc_id: str):
        """
        :param Sequence['GetServerGroupsGroupHealthCheckConfigArgs'] health_check_configs: The configuration of health checks.
        :param str id: The ID of the Server Group.
        :param str protocol: The server protocol. Valid values: `HTTP` and `HTTPS`. Default value: `HTTP`.
        :param str scheduler: The scheduling algorithm. Valid values: `Wrr`, `Wlc` and `Sch`.
        :param str server_group_id: The first ID of the res ource.
        :param str server_group_name: The name of the resource.
        :param Sequence['GetServerGroupsGroupServerArgs'] servers: The backend server.
        :param str status: The status of the resource. Valid values: `Provisioning`, `Available` and `Configuring`.
        :param Sequence['GetServerGroupsGroupStickySessionConfigArgs'] sticky_session_configs: The configuration of the sticky session.
        :param str vpc_id: The ID of the VPC that you want to access.
        """
        pulumi.set(__self__, "health_check_configs", health_check_configs)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "scheduler", scheduler)
        pulumi.set(__self__, "server_group_id", server_group_id)
        pulumi.set(__self__, "server_group_name", server_group_name)
        pulumi.set(__self__, "servers", servers)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "sticky_session_configs", sticky_session_configs)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="healthCheckConfigs")
    def health_check_configs(self) -> Sequence['outputs.GetServerGroupsGroupHealthCheckConfigResult']:
        """
        The configuration of health checks.
        """
        return pulumi.get(self, "health_check_configs")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Server Group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The server protocol. Valid values: `HTTP` and `HTTPS`. Default value: `HTTP`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def scheduler(self) -> str:
        """
        The scheduling algorithm. Valid values: `Wrr`, `Wlc` and `Sch`.
        """
        return pulumi.get(self, "scheduler")

    @property
    @pulumi.getter(name="serverGroupId")
    def server_group_id(self) -> str:
        """
        The first ID of the res ource.
        """
        return pulumi.get(self, "server_group_id")

    @property
    @pulumi.getter(name="serverGroupName")
    def server_group_name(self) -> str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "server_group_name")

    @property
    @pulumi.getter
    def servers(self) -> Sequence['outputs.GetServerGroupsGroupServerResult']:
        """
        The backend server.
        """
        return pulumi.get(self, "servers")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the resource. Valid values: `Provisioning`, `Available` and `Configuring`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stickySessionConfigs")
    def sticky_session_configs(self) -> Sequence['outputs.GetServerGroupsGroupStickySessionConfigResult']:
        """
        The configuration of the sticky session.
        """
        return pulumi.get(self, "sticky_session_configs")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The ID of the VPC that you want to access.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetServerGroupsGroupHealthCheckConfigResult(dict):
    def __init__(__self__, *,
                 health_check_codes: Sequence[str],
                 health_check_connect_port: int,
                 health_check_enabled: bool,
                 health_check_host: str,
                 health_check_http_version: str,
                 health_check_interval: int,
                 health_check_method: str,
                 health_check_path: str,
                 health_check_protocol: str,
                 health_check_timeout: int,
                 healthy_threshold: int,
                 unhealthy_threshold: int):
        """
        :param Sequence[str] health_check_codes: The status code for a successful health check. Multiple status codes can be specified as a list. Valid values: `http_2xx`, `http_3xx`, `http_4xx`, and `http_5xx`. Default value: `http_2xx`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        :param int health_check_connect_port: The port of the backend server that is used for health checks. Valid values: `0` to `65535`. Default value: `0`. A value of `0` indicates that a backend server port is used for health checks.
        :param bool health_check_enabled: Indicates whether health checks are enabled. Valid values: `true`, `false`. Default value: `true`.
        :param str health_check_host: The domain name that is used for health checks.
        :param str health_check_http_version: HTTP protocol version. Valid values: `HTTP1.0` and `HTTP1.1`. Default value: `HTTP1.1`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        :param int health_check_interval: The time interval between two consecutive health checks. Unit: seconds. Valid values: `1` to `50`. Default value: `2`.
        :param str health_check_method: Health check method. Valid values: `GET` and `HEAD`. Default: `GET`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        :param str health_check_path: The forwarding rule path of health checks. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        :param str health_check_protocol: Health check protocol. Valid values: `HTTP` and `TCP`.
        :param int health_check_timeout: The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy. Unit: seconds. Valid values: `1` to `300`. Default value: `5`. **NOTE:** If the value of the `HealthCHeckTimeout` parameter is smaller than that of the `HealthCheckInterval` parameter, the value of the `HealthCHeckTimeout` parameter is ignored and the value of the `HealthCheckInterval` parameter is regarded as the timeout period.
        :param int healthy_threshold: The number of health checks that an unhealthy backend server must pass consecutively before it is declared healthy. In this case, the health check state is changed from fail to success. Valid values: `2` to `10`. Default value: `3`.
        :param int unhealthy_threshold: The number of consecutive health checks that a healthy backend server must consecutively fail before it is declared unhealthy. In this case, the health check state is changed from success to fail. Valid values: `2` to `10`. Default value: `3`.
        """
        pulumi.set(__self__, "health_check_codes", health_check_codes)
        pulumi.set(__self__, "health_check_connect_port", health_check_connect_port)
        pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        pulumi.set(__self__, "health_check_host", health_check_host)
        pulumi.set(__self__, "health_check_http_version", health_check_http_version)
        pulumi.set(__self__, "health_check_interval", health_check_interval)
        pulumi.set(__self__, "health_check_method", health_check_method)
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "health_check_protocol", health_check_protocol)
        pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="healthCheckCodes")
    def health_check_codes(self) -> Sequence[str]:
        """
        The status code for a successful health check. Multiple status codes can be specified as a list. Valid values: `http_2xx`, `http_3xx`, `http_4xx`, and `http_5xx`. Default value: `http_2xx`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        """
        return pulumi.get(self, "health_check_codes")

    @property
    @pulumi.getter(name="healthCheckConnectPort")
    def health_check_connect_port(self) -> int:
        """
        The port of the backend server that is used for health checks. Valid values: `0` to `65535`. Default value: `0`. A value of `0` indicates that a backend server port is used for health checks.
        """
        return pulumi.get(self, "health_check_connect_port")

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> bool:
        """
        Indicates whether health checks are enabled. Valid values: `true`, `false`. Default value: `true`.
        """
        return pulumi.get(self, "health_check_enabled")

    @property
    @pulumi.getter(name="healthCheckHost")
    def health_check_host(self) -> str:
        """
        The domain name that is used for health checks.
        """
        return pulumi.get(self, "health_check_host")

    @property
    @pulumi.getter(name="healthCheckHttpVersion")
    def health_check_http_version(self) -> str:
        """
        HTTP protocol version. Valid values: `HTTP1.0` and `HTTP1.1`. Default value: `HTTP1.1`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        """
        return pulumi.get(self, "health_check_http_version")

    @property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> int:
        """
        The time interval between two consecutive health checks. Unit: seconds. Valid values: `1` to `50`. Default value: `2`.
        """
        return pulumi.get(self, "health_check_interval")

    @property
    @pulumi.getter(name="healthCheckMethod")
    def health_check_method(self) -> str:
        """
        Health check method. Valid values: `GET` and `HEAD`. Default: `GET`. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        """
        return pulumi.get(self, "health_check_method")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> str:
        """
        The forwarding rule path of health checks. **NOTE:** This parameter exists if the `HealthCheckProtocol` parameter is set to `HTTP`.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="healthCheckProtocol")
    def health_check_protocol(self) -> str:
        """
        Health check protocol. Valid values: `HTTP` and `TCP`.
        """
        return pulumi.get(self, "health_check_protocol")

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> int:
        """
        The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy. Unit: seconds. Valid values: `1` to `300`. Default value: `5`. **NOTE:** If the value of the `HealthCHeckTimeout` parameter is smaller than that of the `HealthCheckInterval` parameter, the value of the `HealthCHeckTimeout` parameter is ignored and the value of the `HealthCheckInterval` parameter is regarded as the timeout period.
        """
        return pulumi.get(self, "health_check_timeout")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        """
        The number of health checks that an unhealthy backend server must pass consecutively before it is declared healthy. In this case, the health check state is changed from fail to success. Valid values: `2` to `10`. Default value: `3`.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        """
        The number of consecutive health checks that a healthy backend server must consecutively fail before it is declared unhealthy. In this case, the health check state is changed from success to fail. Valid values: `2` to `10`. Default value: `3`.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetServerGroupsGroupServerResult(dict):
    def __init__(__self__, *,
                 description: str,
                 port: int,
                 server_id: str,
                 server_ip: str,
                 server_type: str,
                 status: str,
                 weight: int):
        """
        :param str description: The description of the server.
        :param int port: The port that is used by the server. Valid values: `1` to `65535`.
        :param str server_id: The ID of the ECS instance, ENI instance or ECI instance.
        :param str server_ip: The IP address of the ENI instance when it is in the inclusive ENI mode.
        :param str server_type: The type of the server. The type of the server. Valid values: `Ecs`, `Eni` and `Eci`.
        :param str status: The status of the resource. Valid values: `Provisioning`, `Available` and `Configuring`.
        :param int weight: The weight of the server.  Valid values: `0` to `100`. Default value: `100`. If the value is set to `0`, no requests are forwarded to the server.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "server_ip", server_ip)
        pulumi.set(__self__, "server_type", server_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the server.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port that is used by the server. Valid values: `1` to `65535`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> str:
        """
        The ID of the ECS instance, ENI instance or ECI instance.
        """
        return pulumi.get(self, "server_id")

    @property
    @pulumi.getter(name="serverIp")
    def server_ip(self) -> str:
        """
        The IP address of the ENI instance when it is in the inclusive ENI mode.
        """
        return pulumi.get(self, "server_ip")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> str:
        """
        The type of the server. The type of the server. Valid values: `Ecs`, `Eni` and `Eci`.
        """
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the resource. Valid values: `Provisioning`, `Available` and `Configuring`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight of the server.  Valid values: `0` to `100`. Default value: `100`. If the value is set to `0`, no requests are forwarded to the server.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetServerGroupsGroupStickySessionConfigResult(dict):
    def __init__(__self__, *,
                 cookie: str,
                 cookie_timeout: int,
                 sticky_session_enabled: bool,
                 sticky_session_type: str):
        """
        :param str cookie: the cookie that is configured on the server. **NOTE:** This parameter exists if the `StickySession` parameter is set to `On` and the `StickySessionType` parameter is set to `server`.
        :param int cookie_timeout: The timeout period of a cookie. The timeout period of a cookie. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
        :param bool sticky_session_enabled: Indicates whether sticky session is enabled. Values: `true` and `false`. Default value: `false`.  **NOTE:** This parameter exists if the `StickySession` parameter is set to `On`.
        :param str sticky_session_type: The method that is used to handle a cookie. Values: `Server` and `Insert`.
        """
        pulumi.set(__self__, "cookie", cookie)
        pulumi.set(__self__, "cookie_timeout", cookie_timeout)
        pulumi.set(__self__, "sticky_session_enabled", sticky_session_enabled)
        pulumi.set(__self__, "sticky_session_type", sticky_session_type)

    @property
    @pulumi.getter
    def cookie(self) -> str:
        """
        the cookie that is configured on the server. **NOTE:** This parameter exists if the `StickySession` parameter is set to `On` and the `StickySessionType` parameter is set to `server`.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="cookieTimeout")
    def cookie_timeout(self) -> int:
        """
        The timeout period of a cookie. The timeout period of a cookie. Unit: seconds. Valid values: `1` to `86400`. Default value: `1000`.
        """
        return pulumi.get(self, "cookie_timeout")

    @property
    @pulumi.getter(name="stickySessionEnabled")
    def sticky_session_enabled(self) -> bool:
        """
        Indicates whether sticky session is enabled. Values: `true` and `false`. Default value: `false`.  **NOTE:** This parameter exists if the `StickySession` parameter is set to `On`.
        """
        return pulumi.get(self, "sticky_session_enabled")

    @property
    @pulumi.getter(name="stickySessionType")
    def sticky_session_type(self) -> str:
        """
        The method that is used to handle a cookie. Values: `Server` and `Insert`.
        """
        return pulumi.get(self, "sticky_session_type")


@pulumi.output_type
class GetZonesZoneResult(dict):
    def __init__(__self__, *,
                 id: str,
                 local_name: str,
                 zone_id: str):
        """
        :param str id: The ID of zone.
        :param str local_name: The local name.
        :param str zone_id: The zone ID.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "local_name", local_name)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of zone.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="localName")
    def local_name(self) -> str:
        """
        The local name.
        """
        return pulumi.get(self, "local_name")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The zone ID.
        """
        return pulumi.get(self, "zone_id")


